# Основы метапрограммирования

- [Основы метапрограммирования](#основы-метапрограммирования)
  - [Шаблоны функций](#шаблоны-функций)
  - [Шаблоны классов](#шаблоны-классов)
  - [Инстанциирование шаблонов](#инстанциирование-шаблонов)
  - [Перегрузка шаблонов функций](#перегрузка-шаблонов-функций)
  - [Специализация шаблонов](#специализация-шаблонов)
  - [Библиография](#библиография)

__Порождающим программированием__ (метапрограммированием) называется парадигма разработки программного обеспечения, в основе которой лежат идеи описания моделей и трансформации этих моделей в программный код (или программу).

Основным механизмом порождающего программирования в С++ является использование шаблонов классов, шаблонов функций и их специализаций [^1].

## Шаблоны функций

__Шаблоном функций__ называют общее описание семейства функций (обобщенного алгоритма ).

Рассмотрим понятие шаблона функции на примере. Пусть мы определили реализацию функции, которая меняет значения двух целых переменных местами:

```cpp
void swap(int& a, int& b){
  int tmp = a;
  a = b;
  b = tmp;
}
```

Однако, для обмена значениями двух действительных переменных придется в программу добавить следующую функцию, воспользовавшись перегрузкой функции:

```cpp
void swap(float& a, float& b){
  float tmp = a;
  a = b;
  b = tmp;
}
```

Таким образом, для каждого типа приходится переопределять функцию.

Однако, для каждого типа данных функция выглядит одинаково, с точностью до типов переменных. В связи с этим язык С++ предлагает механизм шаблонов, который позволяет описать семейство функций. Пример соответствующего шаблона, меняющего значения двух переменных, приведен ниже:

```cpp
template<typename TYPE>
void swap(TYPE& a, TYPE& b){
  TYPE tmp = a;
  a = b;
  b = tmp;
}
```

Определение шаблона начинается с ключевой конструкции `template<typename TYPE, ...>` где в угловых скобках указываются параметры шаблона. Параметров шаблона может быть любое количество, в качестве параметра может выступать тип или перечислимое значение (целочисленный тип или перечисление).

> Кроме ключевого слова `typename`  для объявления параметров шаблона можно также использовать ключевое слово `class`.

Пока нет вызова функции _swap_ в программе, при компиляции она в бинарном коде не создается (_не инстанцируется_). А если объявить группу вызовов функции с переменными различных типов, то для каждого компилятор создаст свою реализацию на основе шаблона.

Кроме того, в качестве параметра шаблона функции может использоваться перечислимый тип (например, `int`).

Вызов шаблонной функции, в общем, эквивалентен вызову обыкновенной функции. В этом случае компилятор определит, какой тип использовать вместо `TYPE`, на основании типа фактических параметров. Но если подставляемые параметры окажутся разных типов, то компилятор не сможет вывести (_инстанцировать шаблон_) реализацию функции:

```cpp
/**
 * @file metaprogramming_01.cpp
 * @brief Пример использования шаблонов функций
 * @details g++ metaprogramming_01.cpp -o metaprogramming_01
 */
#include <iostream>
template<class TYPE>
TYPE min(TYPE a, TYPE b) {
    if (a < b) {
        return a;
    }
    return b;
}

int main(int argc, char** argv) {
    std::cout << min(1, 2) << std::endl; // OK
    std::cout << min(3.1, 1.2) << std::endl; // OK
    std::cout << min(5, 2.1) << std::endl; // Ошибка, компилятор не может вывести общий тип.
    return 0;
}
```

Эту проблему можно решить явным указанием подставляемого в шаблон типа:

```cpp
/**
 * @file metaprogramming_02.cpp
 * @brief Явное указание типа в шаблоне функции
 * @details g++ metaprogramming_02.cpp -o metaprogramming_02
#include <iostream>
template<class TYPE>
TYPE min(TYPE a, TYPE b) {
    if (a < b) {
        return a;
    }
    return b;
}

int main(int argc, char** argv) {
    std::cout << min(1, 2) << std::endl; // OK
    std::cout << min(3.1, 1.2) << std::endl; // OK
    std::cout << min<double>(5, 2.1) << std::endl; // OK
    return 0;
}
```

__Когда шаблон функций (не) будет работать?__

На этапе компиляции программы компилятор подставляет нужный (наиболее подходящий) тип в шаблон. Но всегда ли получаемая функция будет работоспособна? Очевидно, что нет. Любой алгоритм может быть определен независимо от типа данных, но он обязательно пользуется свойствами этих данных. В случае с шаблонной функцией _min_ это требование определения оператора упорядочения (оператор `<`).

Любой шаблон функции предполагает наличие определенных свойств параметризованного типа, в зависимости от реализации (например, оператора копирования, оператора сравнения, наличия определенного метода и т.д.). В текущем стандарте языка С++ за это отвечает понятие _концепций_ [^2].

## Шаблоны классов

__Шаблоном классов__ называется описание множества типов данных с одинаковым поведением[^3].

Стандартным примером шаблона класса являются контейнеры. Однако сфера их применения этим не ограничивается.

Пример описания шаблона класса:

```cpp
template<typename TYPE>
class Box{
    // implementation
    TYPE value_;
public:
    typedef TYPE valueType;

    Box(TYPE value): value_(value) {}
    const TYPE& value() const {
        return value_;
    }
};
```

На практике программирования С++ классы разделяют на два файла: заголовочный файл (`.h`) и файл реализации (`.cpp`). Однако, особенность определения шаблонов классов требует объявления и реализации в одном файле, обычно в заголовочном файле.

## Инстанциирование шаблонов

Термин _инстанциирование_ (создание экземпляра) может относиться как к объявлению переменных, так и к созданию конкретных реализаций шаблонных функций.

_Инстанцирование шаблона_ – это генерация кода функции или класса по шаблону для конкретных параметров. Различают _неявное инстанцирование_, которое происходит при вызове функции или создании объекта класса, и _явное инстанциирование_ с помощью резервированного слова `template`.

Пример инстанциирования функции `swap`:

```cpp
/**
 * @file metaprogramming_03.cpp
 * @brief Пример инстанциирования шаблонов функций
 * @details g++ metaprogramming_03.cpp -o metaprogramming_03
 */
#include <iostream>

template<typename TYPE>
void swap(TYPE& p1, TYPE& p2) {
  TYPE tmp = p1;
  p1 = p2;
  p2 = tmp;
}

// явное инстанциирование
template void swap(int&, int&);

int main() {
  double a = 10;
  double b = 12;
  std::cout << "a: " << a << ", b: " << b << std::endl;
// неявное инстанциирование
  swap(a, b);
  std::cout << "a: " << a << ", b: " << b << std::endl;
  return 0;
}
```

В приведённом примере явное инстанциирование может быть выполнено для всех необходимых типов. В этом случае, каждая инстанциированная функция будет добавлена в бинарный код программы на этапе компиляции.

## Перегрузка шаблонов функций

Шаблоны функций можно перегружать, в этом случае они будут отличаться только параметрами самой функции. Хорошим примером является перегрузка функции `swap` для указателей:

```cpp
/**
 * @file metaprogramming_04.cpp
 * @brief Пример перегрузки шаблонов функций
 * @details g++ metaprogramming_04.cpp -o metaprogramming_04
 */
#include <iostream>

template<typename TYPE>
void swap(TYPE& p1, TYPE& p2) {
  TYPE tmp = p1;
  p1 = p2;
  p2 = tmp;
}

template<typename TYPE>
void swap(TYPE* p1, TYPE* p2) {
  TYPE tmp = *p1;
  *p1 = *p2;
  *p2 = tmp;
}

int main() {
  double a = 10;
  double b = 12;

  double* p1 = &a;
  double* p2 = &b;
  std::cout << "*p1: " << *p1 << ", *p2: " << *p2 << std::endl;
// неявное инстанциирование
  swap(p1, p2);
  std::cout << "*p1: " << *p1 << ", *p2: " << *p2 << std::endl;
  return 0;
}
```

## Специализация шаблонов

Можно _специализировать_, то есть изменять для определенных типов данных реализацию шаблона функции, отдельных методов шаблона класса или шаблона класса целиком.

При специализации функций и отдельных методов допускается только полная специализация. Перед определением специализации пишется `template <>`, а после имени функции или класса добавляется список аргументов основного шаблона в `<>`. Аналогичной функциональности можно добиться, определив обычную функцию или перегрузить шаблон функции. Разница в том, что генерация кода для обычной функции будет происходить при компиляции её определения (т.е. всегда), а для шаблона и специализации – при первом использовании (инстанцировании).

Пример специализации шаблонов:

```cpp
template<typename TYPE>
void print(TYPE p) {
  std::cout << p.toString() << std::endl;
}
template<>
void print(int p) {
  std::cout << p << std::endl;
}
template<>
void print(float p) {
  std::cout << p << std::endl;
}
template<>
void print(std::string p) {
  std::cout << p << std::endl;
}
```

В этом примере параметризованный шаблон `print` будет работать только с типами, которые имеют метод `toString()`. Однако, для типов `int`, `float` и `std::string` определены свои реализации.

Ещё один пример, показывающий использование специализации шаблонов для вычислений на этапе компиляции:

```cpp
/**
 * @file fibonacci.cpp
 * @brief Пример вычисления чисел Фибоначчи на этапе компиляции
 * @details g++ fibonacci.cpp -o fibonacci
 */
#include <iostream>

template <size_t index>
size_t fibonacci()
{
    return fibonacci<index - 1>() + fibonacci<index - 2>();
}

template <>
size_t fibonacci<0>()
{
    return 0;
}

template <>
size_t fibonacci<1>()
{
    return 1;
}

int main()
{
    std::cout << fibonacci<10>() << std::endl;
    return 0;
}
```

## Библиография

[^1]: [Дэвид Вандевурд, Николай М. Джосаттис. Шаблоны C++: справочник разработчика](https://www.google.com/search?client=opera&q=Дэвид+Вандевурд%2C+Николай+М.+Джосаттис.+Шаблоны+C%2B%2B%3A+справочник+разработчика&sourceid=opera&ie=UTF-8&oe=UTF-8)
[^2]: [Concepts, cppreference.com](https://en.cppreference.com/w/cpp/concepts)
[^3]: [Templates, cppreference.com](https://en.cppreference.com/w/cpp/language/templates)
