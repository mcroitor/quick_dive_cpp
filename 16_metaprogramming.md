# Метапрограммирование

- [Метапрограммирование](#метапрограммирование)
  - [шаблонные функции](#шаблонные-функции)
    - [Когда шаблонная функция (не) будет работать?](#когда-шаблонная-функция-не-будет-работать)
  - [шаблонные классы](#шаблонные-классы)
  - [инстанциирование шаблонов](#инстанциирование-шаблонов)
  - [специализация шаблонов](#специализация-шаблонов)
  - [конфигурации шаблонных классов](#конфигурации-шаблонных-классов)

__Порождающим программированием__ \(метапрограммированием\) называется парадигма разработки программного обеспечения, в основе которой лежат идеи описания моделей и трансформации этих моделей в программный код \(или программу\).

Основным механизмом порождающего программирования в С++ является использование шаблонов классов, шаблонов функций и их специализаций.

## шаблонные функции

__Шаблоном функций__ называют общее описание семейства функций \(обобщенного алгоритма \). 

```cpp
int min(int a, int b){
  int result = a;
  if(b < a) {
    result = b;
  }
  return result;
}
```

Если нам понадобится поиск минимального целого числа, то можно воспользоваться функцией, представленной в примере. Однако, для поиска минимума среди действительных чисел придется в программу добавить следующую функцию:

```cpp
float min(float a, float b){
  float result = a;
  if(b < a) {
    result = b;
  }
  return result;
}
```

Таким образом, для каждого типа приходится переопределять функцию.

Однако, для каждого типа данных функция выглядит одинаково. В связи с этим язык С++ предлагает механизм шаблонов, который позволяет описать семейство функций. Пример соответсвующего шаблона, определяющего минимальный элемент, приведен ниже:

```cpp
template<typename TYPE>
TYPE min(TYPE a, TYPE b){
  TYPE result = a;
  if(b < a) {
    result = b;
  }
  return result;
}
```

Определение шаблона начинается с ключевой конструкции `template<typename TYPE, ...>` где в угловых скобках указываются параметры шаблона. Параметров шаблона может быть любое количество, в качестве параметра может быть тип или перечислимое значение.

Пока нет вызова функции _min_ в программе, при компиляции она в бинарном коде не создается \(_не инстанцируется_\). А если объявить группу вызовов функции с переменными различных типов, то для каждого компилятор создаст свою реализацию на основе шаблона.

Вызов шаблонной функции, в общем, эквивалентен вызову обыкновенной функции. В этом случае компилятор определит, какой тип использовать вместо TYPE, на основании типа фактических параметров. Но если подставляемые параметры окажутся разных типов, то компилятор не сможет вывести \(инстанцировать шаблон\) реализацию функции:

```cpp
#include <iostream>
template<class TYPE>
TYPE min(TYPE a, TYPE b) {
    if (a < b) {
        return a;
    }
    return b;
}

int main(int argc, char** argv) {
    std::cout << min(1, 2) << std::endl; // OK
    std::cout << min(3.1, 1.2) << std::endl; // OK
    std::cout << min(5, 2.1) << std::endl; // error! can`t deduce from template!
    return 0;
}
```

Эту проблему можно решить явным указанием подставляемого в шаблон типа:

```cpp
#include <iostream>
template<class TYPE>
TYPE min(TYPE a, TYPE b) {
    if (a < b) {
        return a;
    }
    return b;
}

int main(int argc, char** argv) {
    std::cout << min(1, 2) << std::endl; // OK
    std::cout << min(3.1, 1.2) << std::endl; // OK
    std::cout << min<double>(5, 2.1) << std::endl; // OK
    return 0;
}
```

### Когда шаблонная функция \(не\) будет работать?

На этапе компиляции программы компилятор подставляет нужный \(наиболее подходящий\) тип в шаблон. Но всегда ли получаемая функция будет работоспособна? Очевидно, что нет. Любой алгоритм может быть определен независимо от типа данных, но он обязательно пользуется свойствами этих данных. В случае с шаблонной функцией _min_ это требование определения оператора упорядочения \(оператор `<`\).

Любой шаблон функции предполагает наличие определенных свойств параметризованного типа, в зависимости от реализации \(например, оператора копирования, оператора сравнения, наличия определенного метода и т.д.\). В ожидаемом стандарте языка С++ за это будут отвечать [_концепции_](https://en.cppreference.com/w/cpp/concepts).

## шаблонные классы

__Шаблоном классов__ называется описание множества типов данных с одинаковым поведением. 

Стандартным примером шаблона классов являются контейнеры. Однако сфера их применения этим не ограничивается. 

Пример описания шаблона классов:

```cpp
template<typename TYPE>
class Box{
    // implementation
    TYPE value_;
public:
    typedef TYPE valueType;

    Box(TYPE value): value_(value) {}
    const TYPE& value() const {
        return value_;
    }
};
```

## инстанциирование шаблонов

## специализация шаблонов

## конфигурации шаблонных классов

