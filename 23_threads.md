# Многопоточное программирование

- [Многопоточное программирование](#многопоточное-программирование)
  - [Понятия многопоточного программирования](#понятия-многопоточного-программирования)
  - [Потоки](#потоки)
  - [Проблема разделения данных между потоками](#проблема-разделения-данных-между-потоками)
    - [мьютексы](#мьютексы)
    - [Атомарные переменные и операции](#атомарные-переменные-и-операции)
  - [Асинхронное программирование](#асинхронное-программирование)
  - [Синхронизация потоков](#синхронизация-потоков)
  - [Параллельные алгоритмы](#параллельные-алгоритмы)

## Понятия многопоточного программирования

__Программой__ называется последовательность инструкций (сохраненной в файле, исполняемом или интерпретируемом). __Процесс__ - непосредственное выполнение программы (её инструкций). Также процессом иногда называют совокупность исполняемой программы со связанными с ней ресурсами: адресным пространством, глобальными переменными, открытыми файлами и т.д. В рамках одного процесса может работать один или несколько _потоков_.

__Потоком выполнения__ (или __нитью__, en. __thread__) называется наименьшая исполняемая операционной системой единица. Реализация потоков выполнения и процессов в разных операционных системах отличается друг от друга, но в большинстве случаев поток выполнения находится внутри процесса. Несколько потоков выполнения могут существовать в рамках одного и того же процесса и совместно использовать ресурсы, такие как память, тогда как процессы не разделяют этих ресурсов. В частности, потоки выполнения разделяют последовательность инструкций процесса (его код) и его контекст — значения переменных (регистров процессора и стека вызовов), которые они имеют в любой момент времени.

Возможность операционной системы (и процессора) выполнять несколько потоков одновременно называется __многопоточностью__. Современные компьютеры позволяют выполнять сразу несколько операций за счет нескольких ядер процессора.

__Параллельный алгоритм__ это алгоритм, который может быть реализован по частям на множестве различных вычислительных устройств с последующим объединением полученных результатов и получением корректного результата. Примером параллельного алгоритма является сложение и умножение матриц.

Термин _параллельно_ совсем не означает _точно в один момент_. Два задачи выполняются _параллельно_, если они происходят в течение одного и того же периода времени.

__Параллельным программированием__ (или __многопоточным программированием__) называется метод написания программ, при котором решение задачи разделяется на несколько независимых подзадач, каждая из которых будет выполняться одновременно с другими, на различных процессорах (ядрах) в рамках одного физического или виртуального компьютера.

__Распределенным программированием__ называется метод написания программ, при котором решение задачи разделяется на несколько независимых подзадач, каждая из которых будет выполняться одновременно с другими, на различных компьютерах, физических или виртуальных.

При проектировании параллельных алгоритмов необходимо выполнять следующие шаги:

- __декомпозиция__ - процесс разбиения задачи и её решения на части;
- __связь__ - определение взаимодействий между частями решения задачи;
- __синхронизация__ - координация порядка выполнения частей решения задачи.

Потоки, выполняющиеся параллельно, могут иметь во владении свою память, однако также они имеют доступ к общей памяти, называемой  __разделяемой памятью__ (en. shared memory).

Начиная со стандарта языка __С++11__ язык предлагает поддержку многопоточного программирования. C++ поддерживает следующие элементы параллельного программирования (классификация по стандартам):

- __С++11__
  - модель памяти
  - атомарные переменные
  - потоки
  - мьютексы (двоичные семафоры) и блокировщики
  - локальные данные потока
  - задания
- __С++14__
  - блокировщики чтения / записи
- __С++17__
  - параллельные алгоритмы
- __С++20__
  - атомарные умные указатели
  - потоки с ожиданием
  - защелки и барьеры
  - семафоры общего вида
  - сопрограммы
- __С++23__
  - исполнители
  - блоки заданий
  - транзакционная память
  - векторы с параллельной обработкой

## Потоки

Работа с потоками в языке С++ определена в заголовочном файле `<thread>`. Создание потока определяется через объявление объекта класса `std::thread`, в качестве параметра конструктора класса указывается функция, которая будет запускаться в дочернем потоке, а также, возможно, параметры данной функции.

Простейший пример создания дочернего потока продемонстрирован ниже:

```cpp
#include <thread>
#include <iostream>

void hello() {
    std::cout << "hello!";
}
int main() {
    std::thread t(hello);
    t.join();
    return 0;
}
```

В данном примере создаётся поток, в котором выполняется функция `hello`, а главная программа ожидает завершения дочернего потока (`t.join();`). Если не ожидать завершения дочернего потока, то выполнение программы не определено (и обычно завершается падением дочернего потока с ошибкой).

Начиная со стандарта _С++20_ можно создавать автоматически присоединяемые потоки, используя класс `std::jthread`.

```cpp
#include <thread>
#include <iostream>

void hello() {
    std::cout << "hello from " << std::this_thread::get_id() << std::endl;
}

int main() {
    std::jthread t(hello);
    return 0;
}
```

## Проблема разделения данных между потоками

Одной из проблем параллельного программирования является взаимодействие потоков с общей памятью. Если два потока имеют доступ к одному и тому же участку памяти, то они могут мешать друг другу, меняя значение, хранимое в данном сегменте памяти. Проблема, когда результат выполнения операций в двух или более потоках зависит от их порядка выполнения называется __состоянием гонки__.

Решения проблемы гонки:

- заключить структуру данных в механизм защиты, который гарантирует изменение объекта захватившим его потоком;
- переписать структуру данных таким образом, чтобы исключить гонку (программирование без блокировок).

### мьютексы

__Мьютекс__ (от en. mutual exclusion - взаимное исключение) - простейший объект (примитив синхронизации), позволяющий помечать все фрагменты кода к одной и той же структуре данных с целью предотвращения состояния гонки.

Мьютекс объявлен в заголовочном файле `<mutex>`, называется `std::mutex`. Блокирование / разблокирование структуры выполняется при помощи вызова методов `lock` / `unlock`, однако прямое их использование не рекомендуется.

### Атомарные переменные и операции

Операция называется __атомарной__ если она не может быть выполнена частично, она либо выполняется целиком либо не выполняется. Атомарная операция выполняется только одним потоком.

Атомарность может обеспечиваться аппаратно или программно. В первом случае используются специальные машинные инструкции, атомарность которых гарантируется процессором. Во втором случае используются средства синхронизации, которые блокируют разделяемый ресурс с целью выполнения над ним операции. _Блокировка является атомарной операцией_.

__Атомарный тип данных__ - тип данных, операции с которым являются атомарными.

Определения стандартных атомарных типов даны в заголовочном файле `<atomic>`.

## Асинхронное программирование

__Асинхронное программирование__ - это способ организации программы, при котором некоторые операции выполняются не в том порядке, в котором они были вызваны. Вместо того, чтобы ждать завершения операции, программа продолжает работу, а операция завершается в фоновом режиме.

В стандарте С++11 введен класс `std::future`, который позволяет получить результат выполнения асинхронной операции. Класс `std::future` представляет собой объект, который хранит результат асинхронной операции. Он предоставляет методы для проверки завершения операции и получения результата.

```cpp
#include <iostream>
#include <future>
#include <thread>
#include <chrono>

int main() {
    std::future<int> f = std::async([]() {
        std::this_thread::sleep_for(std::chrono::seconds(3));
        return 8;
    });
    std::cout << "waiting..." << std::endl;
    std::cout << f.get() << std::endl;
    return 0;
}
```

## Синхронизация потоков

## Параллельные алгоритмы

В стандарт C++17 к стандартной библиотеке C++ добавлена концепция алгоритмов параллельных вычислений. Она представлена в виде дополнительных переопределений многих функций, работающих с диапазонами, например `std::find`, `std::transform` или `std::reduce`. У параллельных версий такая же сигнатура, что и у "обычных" однопоточных, за исключением добавления нового первого параметра, определяющего политику выполнения.

```cpp
std::vector<int> my_data;
std::sort(std::execution::par,my_data.begin(),my_data.end());
```

Политика выполнения `std::execution::par` указывает стандартной библиотеке, что данный вызов разрешено выполнять в качестве алгоритма параллельных вычислений с задействованием сразу нескольких потоков. Следует отметить, что это разрешение, а не требование — библиотека вольна по-прежнему выполнять код в одном потоке.

Стандартом предусмотрены три политики выполнения:

- `std::execution::sequenced_policy`;
- `std::execution::parallel_policy`;
- `std::execution::parallel_unsequenced_policy`.

Они представляют собой классы, определенные в заголовке `<execution>`. Там же определены три соответствующих объекта политик, которые передаются алгоритмам:

- `std::execution::seq` - _последовательная политика_ (sequenced policy) не является политикой параллелизма: ее использование заставляет реализацию выполнять все операции в потоке, где была вызвана функция, то есть без распараллеливания. Но все же это политика выполнения, в силу чего она оказывает такое же влияние на алгоритмическую сложность и на выдачу исключений, как и все другие стандартные политики.
- `std::execution::par` - _параллельная политика_ (parallel policy) предоставляет основное параллельное выполнение сразу в нескольких потоках. Операции можно выполнять либо в потоке, вызвавшем алгоритм, либо в потоках, созданных библиотекой. Операции, выполняемые в конкретном потоке, должны выполняться в определенном порядке и не перемежаться, но точный порядок не определен и от вызова к вызову может варьироваться. Конкретная операция будет выполняться в фиксированном потоке на протяжении всего времени.
- `std::execution::par_unseq` - _политика параллельного неупорядоченного выполнения_ (parallel unsequenced policy) предоставляет библиотеке наибольший масштаб распараллеливания алгоритма в обмен на предъявление строжайших требований к итераторам, значениям и вызываемым объектам, используемым с алгоритмом.
