# Пользовательские типы данных

- [Пользовательские типы данных](#пользовательские-типы-данных)
  - [псевдонимы](#псевдонимы)
  - [перечисления](#перечисления)
  - [структуры](#структуры)
  - [классы](#классы)
    - [ключевое слово this](#ключевое-слово-this)
  - [Библиография](#библиография)

## псевдонимы

Для сокращения кода и улучшения читаемости программ можно определять псевдонимы типов. Кроме того, определение псевдонимов упрощает работу с указателями на функции.

Псевдоним типа определяется при помощи ключевого слова __typedef__.

```cpp
// улучшаем читаемость кода
typedef unsigned char age_type;

// удобно для создания указателей на функции.
// [Указатель на функцию](https://sweethome.gitbook.io/advanced-cpp/particularities/function_pointers)
typedef void (*pfunc_type)(void);

// сокращаем длинный тип
typedef std::vector<unsigned int>::const_iterator const_iterator;

age_type age;
pfunc_type handlers[10];
const_iterator it;
```

Также псевдонимы типов можно определять при помощи ключевого слова __using__.

Синтаксис:

```cpp
using <новое имя типа> = <тип>;
```

Примеры:

```cpp
using BYTE = unsigned char;
using WORD = unsigned short int;

BYTE byte;
WORD word;
```

## перечисления

Перечислением называется пользовательский тип данных, определённый как набор целочисленных констант. Переменная перечисления может принимать значения только из указанного в наборе значения.

Синтаксис:

```cpp
enum <имя типа> {
  <константа_1>,
  <константа_2>,
  ...
  <константа_n>
};
```

или

```cpp
enum class <имя типа> {
  <константа_1>,
  <константа_2>,
  ...
  <константа_n>
};
```

Примеры объявления перечислений:

```cpp
enum CURRENCY {
  MDL,
  USD,
  EUR
};

enum class color_type {
  white,
  red,
  green,
  blue,
  black,
};

enum class direction_t {
  north,
  south,
  east,
  west
};
```

Константы перечислений принимают последовательные целочисленные значения, начиная с нуля. Соответственно, константа `CURRENCY::MDL` будет равна нулю, `CURRENCY::USD` и так далее. Однако, настоятельно не рекомендуется использовать числовые значения для работы с перечислениями, а их имена.

Значение перечисления указывается как `<имя типа>::<имя константы>`.

Примеры объявления переменных типа перечисление с их инициализацией:

```cpp
CURRENCY valuta = CURRENCY::MDL;
color_type backgroundColor = color_type::white;
direction_t direction = direction_t::east;
```

## структуры

Структура это пользовательский тип данных, объединяющий по смыслу значения базовых типов или других структур. Примерами структур можно назвать комплексное число, планарную точку или планарный вектор как объединение двух действительных переменных.

```cpp
struct <имя структуры> {
  /* тип_1 */ /* свойство_1 */;
  /* тип_2 */ /* свойство_2 */;
  // ...
  /* тип_n */ /* свойство_n */;
};
```

Пример объявления структуры _точка на плоскости_:

```cpp
struct point_t {
  double x;
  double y;
};
```

Объявление объекта структуры эквивалентно объявлению переменной. Инициализация объекта может выполняться как перечисление значений полей объекта через запятую, взятое в фигурные скобки:

```cpp
point_t pt {1., 0.};
pt.x = -3.7;
pt.y = 12.2;
```

Доступ к полям объекта структуры осуществляется при помощи оператора `.`, как было показано в примере.

## классы

Классы представляют собой расширенное представление структур. Они позволяют группировать не только данные под одним именем, но также и функции, оперирующие с этими данными.

Формально, _класс это пользовательский тип данных, описывающий абстракцию объектов реального мира_. Экземпляр класса (то есть переменная данного типа) называется _объектом_ (вообще, любую переменную можно назвать объектом типа).

Синтаксис объявления класса:

```cpp
class <имя класса> {
private:
  /* тип_1 */ /* свойство_1 */;
  /* тип_2 */ /* свойство_2 */;
  // ...
  /* тип_n */ /* свойство_n */;

public:
  /* тип_1 */ /* метод_1 */;
  /* тип_2 */ /* метод_2 */;
  // ...
  /* тип_n */ /* метод_n */;
};
```

Переменные, объявленные в классе, называются __члена-данными__ (member data), __свойствами__ (attributes), а также __полями__ (fields), функции, объявленные в классе, называются __член-функциями__ (member functions) или __методами__ (methods).

В классе можно управлять доступом к объявленным переменным и функциям, делая их доступными для пользователя или скрывая их. Это осуществляется при помощи ключевых слов __public__, __private__ и __protected__, которые определяют доступ сразу для группы членов класса.

По умолчанию доступ к членам класса закрыт.

> В С++ структуры от классов отличаются только доступом: в структурах по умолчанию доступ к элементам открыт, в классах же он по умолчанию закрыт.

Пример объявления класса _игровой персонаж_:

```cpp
class GameCharacter {
  std::string _name;
  size_t      _health;
  size_t      _attack;
  size_t      _defence;
  point_t     _position;

public:
  GameCharacter(string); // конструктор
  void Move(direction_t);

  void Attack(GameCharacter&);
}
```

В С++ обычно отделяют объявление класса (и не только) от реализации. Хорошей практикой является создание для каждого класса двух файлов: в _заголовочном файле_ описывается класс, в _файле исходного кода_ прописывается реализация методов.

При описании реализации методов класса используется следующий синтаксис:

```cpp
<возвращаемый тип> <имя класса>::<имя метода>(<параметры>) {
  <тело функции>
}
```

```cpp
GameCharacter::GameCharacter(std::string name): 
    _name(name), _attack(10), _health(100), _defence(2)
{
}

void GameCharacter::Move(direction_t direction)
{
    switch (direction) {
        case direction_t::north: // top
            _position.x -= 1;
            break;
        case direction_t::south: // bottom
            _position.x += 1;
            break;
        case direction_t::east: // right
            _position.y += 1;
            break;
        case direction_t::west: // left
            _position.y -= 1;
            break;
    }
}

void GameCharacter::Attack(GameCharacter & gameCharacter)
{
    size_t damage = 0;
    if(this->_attack >= gameCharacter._defence) {
        damage = this->_attack - gameCharacter._defence;
    }
    if(gameCharacter._health >= damage) {
        gameCharacter._health -= gameCharacter._health - damage;
    }
    else {
        gameCharacter._health = 0;
    }    
}
```

### ключевое слово this

Класс описывает множество объектов с одинаковыми свойствами и поведением, однако поведение (то есть использование методов) относится к конкретному объекту. Для того, чтобы указать, что действие относится к объекту, используется ключевое слово __this__. Данное ключевое слово представляет собой указатель на (текущий) объект, который предоставляет доступ к свойствам и методам объекта при помощи оператора _стрелка_ `->`.

Ключевое слово __this__ используется только в контексте методов класса.

Пример использования:

```cpp
void GameCharacter::Move(direction_t direction)
{
    switch (direction) {
        case direction_t::north: // top
            this->_position.x -= 1;
            break;
        case direction_t::south: // bottom
            this->_position.x += 1;
            break;
        case direction_t::east: // right
            this->_position.y += 1;
            break;
        case direction_t::west: // left
            this->_position.y -= 1;
            break;
    }
}
```

Более подробно классы рассматриваются в контексте [объектно-ориентированного программирования](./14_oop.md).

## Библиография

1. [Стандарт языка С++](https://github.com/cplusplus/draft/releases/tag/n4917)
2. [cppreference.com](https://en.cppreference.com/w/cpp/language/class)
