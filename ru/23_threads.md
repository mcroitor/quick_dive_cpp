# Многопоточное программирование

- [Многопоточное программирование](#многопоточное-программирование)
  - [Понятия многопоточного программирования](#понятия-многопоточного-программирования)
  - [Потоки](#потоки)
  - [Проблема разделения данных между потоками](#проблема-разделения-данных-между-потоками)
    - [мьютексы](#мьютексы)
    - [Атомарные переменные и операции](#атомарные-переменные-и-операции)
  - [Асинхронное программирование](#асинхронное-программирование)
  - [Синхронизация потоков](#синхронизация-потоков)

## Понятия многопоточного программирования

__Программой__ называется последовательность инструкций (сохраненной в файле, исполняемом или интерпретируемом). __Процесс__ - непосредственное выполнение программы (её инструкций). Также процессом иногда называют совокупность исполняемой программы со связанными с ней ресурсами: адресным пространством, глобальными переменными, открытыми файлами и т.д. В рамках одного процесса может работать один или несколько _потоков_.

__Потоком выполнения__ (или __нитью__, en. __thread__) называется наименьшая исполняемая опреационной системой единица. Реализация потоков выполнения и процессов в разных операционных системах отличается друг от друга, но в большинстве случаев поток выполнения находится внутри процесса. Несколько потоков выполнения могут существовать в рамках одного и того же процесса и совместно использовать ресурсы, такие как память, тогда как процессы не разделяют этих ресурсов. В частности, потоки выполнения разделяют последовательность инструкций процесса (его код) и его контекст — значения переменных (регистров процессора и стека вызовов), которые они имеют в любой момент времени.

Возможность операционной системы (и процессора) выполнять несколько потоков одновременно называется __многопоточностью__. Современные компьютеры позволяют выполнять сразу несколько операций за счет нескольких ядер процессора.

__Параллельный алгоритм__ это алгоритм, который может быть реализован по частям на множестве различных вычислительных устройств с последующим объединением полученных результатов и получением корректного результата. Примером параллельного алгоритма является сложение и умножение матриц.

Термин _параллельно_ совсем не означает _точно в один момент_. Два задачи выполняются _параллельно_, если они происходят в течение одного и того же периода времени.

__Параллельным программированием__ (или __многопоточным программированием__) называется метод написания программ, при котором решение задачи разделяется на несколько независимых подзадач, каждая из которых будет выполняться одновременно с другими, на различных процессорах (ядрах) в рамках одного физического или виртуального компьютера.

__Распределенным программированием__ называется метод написания программ, при котором решение задачи разделяется на несколько независимых подзадач, каждая из которых будет выполняться одновременно с другими, на различных компьютерах, физических или виртуальных.

При проектировании параллельных алгоритмов необходимо выполнять следующие шаги:

 - __декомпозиция__ - процесс разбиения задачи и её решения на части;
 - __связь__ - определение взаимодействий между частями решения задачи;
 - __синхронизация__ - координация порядка выполнения частей решения задачи. 

Потоки, выполняющиеся параллельно, могут иметь во владении свою память, однако также они имеют доступ к общей памяти, называемой  __разделяемой памятью__ (en. shared memory).

Начиная со стандарта языка __С++11__ язык предлагает поддержку многоточного программирования. C++ поддерживает следующие элементы параллельного программирования (классификация по стандартам):

 * __С++11__
   * модель памяти
   * атомарные переменные
   * потоки
   * мьютексы (двоичные семафоры) и блокировщики
   * локальные данные потока
   * задания
 * __С++14__
   * блокировщики чтения / записи
 * __С++17__
   * параллельные алгоритмы
 * __С++20__
   * атомарные умные указатели
   * потоки с ожиданием
   * защелки и барьеры
   * семафоры общего вида
   * сопрограммы
 * __С++23__
   * исполнители
   * блоки заданий
   * транзакционная память
   * векторы с параллельной обработкой

## Потоки

Работа с потоками в языке С++ определена в заголовочном файле `<thread>`. Создание потока определяется через объявление объекта класса `std::thread`, в качестве параметра конструктора класса указывается функция, которая будет запускаться в дочернем потоке, а ткаже, возможно, параметры данной функции.

Простейший пример создания дочернего потока продемонстрирован ниже:


```cpp
#include <thread>
#include <iostream>

void hello() {
    std::cout << "hello!";
}
int main() {
    std::thread t(hello);
    t.join();
    return 0;
}
```

В данном примере создаётся поток, в котором выполняется функция `hello`, а главная программа ожидает завершения дочернего потока (`t.join();`). Если не ожидать завершения дочерного потока, то выполнение программы нерегламентировано (и обычно завершается падением дочернего потока с ошибкой).

Начиная со стандарта _С++20_ можно создавать автоматически присоединяемые потоки, используя класс `std::jthread`.

```cpp
#include <thread>
#include <iostream>

void hello() {
    std::cout << "hello from " << std::this_thread::get_id() << std::endl;
}

int main() {
    std::jthread t(hello);
    return 0;
}
```

## Проблема разделения данных между потоками

Одной из проблем параллельного программирования является взаимодействие потоков с общей памятью. Если два потока имеют доступ к одному и тому же участку памяти, то они могут мешать друг другу, меняя значение, хранимое в данном сегменте памяти. Проблема, когда результат выполнения операций в двух или более потоках зависит от их порядка выполнения называется __состоянием гонки__.

Решения проблемы гонки:

 * заключить структуру данных в механизм защиты, который гарантирует изменение объекта захватившим его потоком;
 * переписать структуру данных таким образом, чтобы исключить гонку (программирование без блокировок).

### мьютексы

__Мьютекс__ (от en. mutual exclusion - взаимное исключение) - простейший объект (примитив синхронизации), позволяющий помечать все фрагменты кода к одной и той же структуре данных с целью предотвращения состояния гонки.

Мьютекс объевлен в заголовочном файле `<mutex>`, называется `std::mutex`. Блокирование / разблокирование структуры выполняется при помощи вызова методов `lock` / `unlock`, однако прямое их использование не рекомендуется.

### Атомарные переменные и операции

Операция называется __атомарной__ если она не может быть выполнена частично, она либо выполняется целиком либо не выполняется. Атомарная операция выполняется только одним потоком.

Атомарность может обеспечиваться аппаратно или программно. В первом случае используются специальные машинные инструкции, атомарность которых гарантируется процессором. Во втором случае используются средства синхронизации, которые блокируют разделяемый ресурс с целью выполнения над ним операции. _Блокировка является атомарной операцией_.

__Атомарный тип данных__ - тип данных, операции с которым являются атомарными.

 - __блокировка__
 - __состояние гонки__
 - __атомарная операция__


## Асинхронное программирование

## Синхронизация потоков
