# объектно-ориентированное программирование

- [объектно-ориентированное программирование](#объектно-ориентированное-программирование)
  - [понятие объектно-ориентированного программирования](#понятие-объектно-ориентированного-программирования)
    - [Абстракция данных](#абстракция-данных)
    - [Инкапсуляция](#инкапсуляция)
    - [создание и разрушение объектов](#создание-и-разрушение-объектов)
    - [Наследование](#наследование)
  - [Вирутальные функции](#вирутальные-функции)
    - [Абстрактные классы](#абстрактные-классы)
    - [Интерфейс](#интерфейс)
  - [Полиморфизм](#полиморфизм)

## понятие объектно-ориентированного программирования

Основные понятия:

 * __Класс__ – пользовательский тип данных, представляющий собой абстракцию объектов реального мира, включающий в себя набор данных, описывающих эти объекты, а также функций, описывающих поведение этих объектов;
 * __Объект__ – переменная класса;
 * __Интерфейс__ – (интерфейс класса) множество открытых свойств, методов, а также функций;

Класс можно рассматривать как множество объектов с описываемыми классом свойствами. В этом случае свойства определяются интерфейсом класса, а объект класса является элементом данного множества.

### Абстракция данных

__Абстракция данных__ – это использование только тех характеристик объекта, которые с достаточной точностью представляют его в данной системе. Основная идея состоит в том, чтобы представить объект минимальным набором полей и методов и при этом с достаточной точностью для решаемой задачи.

Абстракция является основой объектно-ориентированного программирования и позволяет работать с объектами, не вдаваясь в особенности их реализации.


### Инкапсуляция

__Инкапсуляция__ – изоляция элементов, определяющих структуру (данные) и поведение (методы). Инкапсуляция предполагает разделение класса на интерфейс и реализацию.

Способы применения объекта определяются интерфейсом класса.

```cpp
class vector {
private:
    double x, y;
    void normalize();

public:
    void move(double, double);
    std::string to_string() const;
};

void print(const vector&);
```

В указанном примере класс `vector` инкапсулирует данные `x`, `y` и метод `normalize`. Интерфейс класса определяется методами `move`, `to_string` и функцией `print`.

### создание и разрушение объектов

Специальная функция, совпадающая по имени с названием класса, называется __конструктором__. Данная функция используется для создания объектов класса и инициализации их полей. Один класс может содержать несколько конструкторов, отличающихся по назначению (и параметрам):

 * конструктор без параметров называется конструктором по умолчанию;
 * конструктор, принимающий в качестве параметра объект того же типа называется конструктором копирования.

Конструктор не возвращает значения.

Функция, совпадающая по имени с конструктором, но начиняющаяся с символом `~`, называется __деструктором__. Роль деструктора - правильное освобождение памяти при уничтожении объекта. Класс может иметь только один деструктор.

```cpp
class vector {
    double _x, _y, _z;
public:
    // конструктор по умолчанию
    vector();
    // конструктор с параметрами
    vector(double x, double y, double z);
    // конструктор копирования
    vector(const vector&);
    // деструктор
    ~vector();
}
```

### Наследование

__Наследование__ – один абстрактный тип данных может наследовать данные и функциональность другого типа данных.

Наследование способствует повторному использованию кода.

Класс, наследующий свойства другого класса, называется __дочерним__, __производным__ или __подклассом__.

Класс, производящий наследование в подклассах, называется __родительским классом__, __предком__, __родителем__ или __надклассом__.

Дочерние классы образуются из базовых за счет добавления в определение новых свойств и переопределения некоторых методов.

Пример наследования:

```cpp
class Animal {
    point position;
public:
    Animal();
    virtual ~Animal();

    virtual void eat() const {
        std::cout << "do eat" << std::endl;
    }
    void move(point pt) {
        position = pt;
    }
};

class Cat: Animal {
public:
    Cat();
    virtual ~Cat();

    virtual void eat() const;
};

class Pig: Animal {
public:
    Pig();
    virtual ~Pig();

    virtual void eat() const;
}
```

В связи с тем, что производный класс описывает некоторое подмножество элементов базового класса, указатель на объект базового класса может ссылаться и на объект производного класса. Обратное утверждение неверное \(указатель на объект класса-потомка __не может__ ссылаться на объект базового класса\).

Пример:

```cpp
A* a = new B(); // OK!
B* b = new A(); // ERROR!
```

## Вирутальные функции

Программист может переопределить \(переписать\) функцию базового класса в дочернем классе. Например, в следующих строках кода показана эта возможность:

```cpp
// nopoly.cpp
#include <iostream>

struct A{
    A() {}
    void print() const { std::cout << "A"; }
};

struct B:public A{
    B(){}
    void print() const { std::cout << "B"; }
};

int main(){
     A* obj = new B;
     obj->print();
     obj = new A;
     obj->print();
     return 0; 
}
```

Однако, ожидаемый результат не будет достигнут - на экране  в обоих случаях будет напечатана буква A, а не B. Это связано с тем, что компилятор не может определить, какого типа является объект, находящийся в переменной obj, поэтому вызывается функция родительского объекта. Данная проблема может быть решена при помощи виртуальных функций. В случае использования виртуальных функций компилятор гарантирует вызов своего варианта функции для каждого объекта класса из иерархии.


Метод называется __виртуальным__, если он может быть переопределён в дочернем классе. Пример использования виртуальных функций:

```cpp
// poly01.cpp
#include <сstdio>

struct A{
     A() {}
     virtual void print() const { puts("A"); }
};

struct B:public A{
     B(){}
     virtual void print() const { puts("B"); }
};

int main(){
     A* obj = new B;
     obj->print();
     obj = new A;
     obj->print();
     return 0;
}

```

В примере _poly01.cpp_ мы получим желаемый результат: на экране будет напечатано "BA".

### Абстрактные классы

__Абстрактным методом__ (абстрактной член-функцией, чистой виртуально функцией) называется виртуальная функция без реализации.

```cpp
struct Comparable {
    // чистая виртуальная функция!
    virtual bool equal(Comparable*) = 0; 
};

class Complex: Comparable {
    double real;
    double imaginary;
public:
    virtual bool equal(Comparable*); 
};
```

Если класс имеет хотя бы один абстрактный метод, то данный класс называется __абстрактным классом__.

### Интерфейс

Абстрактный класс может содержать только публичные чистые виртуальные функции. В этом случае иногда (по аналогии с другими языками ОО) этот класс называется интерфейсом.

## Полиморфизм

__Полиморфизм__ механизм, позволяющий использовать данные различных типов в общем контексте. Пример полиморфизма, основанного на неявном приведении типов:

```cpp
bool less(double x, double y) { return x < y; }

int a = 10, b = 15;
less(a, b);
```

Полиморфизм на основе виртуальных функций, называемый также динамическим полиморфизмом, основан на возможности указателя на объект базового класса включать в себя указатель на объект класса-потомка.

Данное свойство может быть использовано при реализации полиморфизма - возможности использования одной и той же функции \(одного и того же имени функции\) с различными типами параметров. Пример динамического полиморфизма с классами из показан в листинге _poly02.cpp_

```cpp
// poly02.cpp
#include <сstdio>
​
struct A{
     A() {}
     virtual void print() const { puts("A"); }
};
​
struct B:public A{
     B(){}
     virtual void print() const { puts("B"); }
};

void print(A* a){
     a->Print();
 }

int main(){
     A* obj = new B;
     print(obj);
     return 0;
 }
```