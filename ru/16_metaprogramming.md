# Метапрограммирование

- [Метапрограммирование](#метапрограммирование)
  - [Шаблоны функций](#шаблоны-функций)
  - [Шаблоны классов](#шаблоны-классов)
  - [инстанциирование шаблонов](#инстанциирование-шаблонов)
  - [Перегрузка шаблонов функций](#перегрузка-шаблонов-функций)
  - [Специализация шаблонов](#специализация-шаблонов)

__Порождающим программированием__ \(метапрограммированием\) называется парадигма разработки программного обеспечения, в основе которой лежат идеи описания моделей и трансформации этих моделей в программный код \(или программу\).

Основным механизмом порождающего программирования в С++ является использование шаблонов классов, шаблонов функций и их специализаций.

## Шаблоны функций

__Шаблоном функций__ называют общее описание семейства функций \(обобщенного алгоритма \).

Рассмотрим понятие шаблона функции на примере. Пусть мы определили реализацию функции, которая меняет значения двух целых переменных местами:

```cpp
void swap(int& a, int& b){
  int tmp = a;
  a = b;
  b = tmp;
}
```

Однако, для обмена значениями двух действительных переменных придется в программу добавить следующую функцию, воспользовавшись перегрузкой функции:

```cpp
void swap(float& a, float& b){
  float tmp = a;
  a = b;
  b = tmp;
}
```

Таким образом, для каждого типа приходится переопределять функцию.

Однако, для каждого типа данных функция выглядит одинаково, с точностью до типов переменных. В связи с этим язык С++ предлагает механизм шаблонов, который позволяет описать семейство функций. Пример соответсвующего шаблона, меняющего значения двух переменных, приведен ниже:

```cpp
template<typename TYPE>
void swap(TYPE& a, TYPE& b){
  TYPE tmp = a;
  a = b;
  b = tmp;
}
```

Определение шаблона начинается с ключевой конструкции `template<typename TYPE, ...>` где в угловых скобках указываются параметры шаблона. Параметров шаблона может быть любое количество, в качестве параметра может быть тип или перечислимое значение. 

> Кроме ключевого слова `typename`  для объявления параметров шаблона можно также использовать ключевое слово `class`.

Пока нет вызова функции _swap_ в программе, при компиляции она в бинарном коде не создается \(_не инстанцируется_\). А если объявить группу вызовов функции с переменными различных типов, то для каждого компилятор создаст свою реализацию на основе шаблона.

Кроме того, в качестве параметра шаблона функции может использоваться перечислимый тип (например, `int`).

Вызов шаблонной функции, в общем, эквивалентен вызову обыкновенной функции. В этом случае компилятор определит, какой тип использовать вместо `TYPE`, на основании типа фактических параметров. Но если подставляемые параметры окажутся разных типов, то компилятор не сможет вывести \(инстанцировать шаблон\) реализацию функции:

```cpp
#include <iostream>
template<class TYPE>
TYPE min(TYPE a, TYPE b) {
    if (a < b) {
        return a;
    }
    return b;
}

int main(int argc, char** argv) {
    std::cout << min(1, 2) << std::endl; // OK
    std::cout << min(3.1, 1.2) << std::endl; // OK
    std::cout << min(5, 2.1) << std::endl; // error! can`t deduce from template!
    return 0;
}
```

Эту проблему можно решить явным указанием подставляемого в шаблон типа:

```cpp
#include <iostream>
template<class TYPE>
TYPE min(TYPE a, TYPE b) {
    if (a < b) {
        return a;
    }
    return b;
}

int main(int argc, char** argv) {
    std::cout << min(1, 2) << std::endl; // OK
    std::cout << min(3.1, 1.2) << std::endl; // OK
    std::cout << min<double>(5, 2.1) << std::endl; // OK
    return 0;
}
```

__Когда шаблон функций \(не\) будет работать?__

На этапе компиляции программы компилятор подставляет нужный \(наиболее подходящий\) тип в шаблон. Но всегда ли получаемая функция будет работоспособна? Очевидно, что нет. Любой алгоритм может быть определен независимо от типа данных, но он обязательно пользуется свойствами этих данных. В случае с шаблонной функцией _min_ это требование определения оператора упорядочения \(оператор `<`\).

Любой шаблон функции предполагает наличие определенных свойств параметризованного типа, в зависимости от реализации \(например, оператора копирования, оператора сравнения, наличия определенного метода и т.д.\). В ожидаемом стандарте языка С++ за это будут отвечать [_концепции_](https://en.cppreference.com/w/cpp/concepts).

## Шаблоны классов

__Шаблоном классов__ называется описание множества типов данных с одинаковым поведением. 

Стандартным примером шаблона классов являются контейнеры. Однако сфера их применения этим не ограничивается. 

Пример описания шаблона классов:

```cpp
template<typename TYPE>
class Box{
    // implementation
    TYPE value_;
public:
    typedef TYPE valueType;

    Box(TYPE value): value_(value) {}
    const TYPE& value() const {
        return value_;
    }
};
```

## инстанциирование шаблонов

Термин _инстанциирование_ (создание экземпляра) может относится как к объявлению переменных, так и к созданию конкретных реализаций шаблонных функций.

_Инстанцирование шаблона_ – это генерация кода функции или класса по шаблону для конкретных параметров. Различают _неявное инстанцирование_, которое происходит при вызове функции или создании объекта класса, и _явное инстанцирование_ с помощью резервированного слова `template`.

Пример инстанциирования функции `swap`:

```cpp
#include <iostream>

template<typename TYPE>
void swap(TYPE& p1, TYPE& p2) {
  TYPE tmp = p1;
  p1 = p2;
  p2 = tmp;
}

// явное инстанциирование
template void swap(int&, int&);

int main() {
  double a = 10;
  double b = 12;
  std::cout << "a: " << a << ", b: " << b << std::endl;
// неявное инстанциирование
  swap(a, b);
  std::cout << "a: " << a << ", b: " << b << std::endl;
  return 0;
}
```

В указанном примере явное инстанциирование может быть выполнено для всех необходимых типов. В этом случае, каждая инстанциированная функция будет добавлена в бинарный код программы на этапе компиляции.

## Перегрузка шаблонов функций

Шаблоны функций можно перегружать, в этом случае они будут отличаться только параметрами самой функции. Хорошим примером является перегрузка функции `swap` для указателей:

```cpp
#include <iostream>

template<typename TYPE>
void swap(TYPE& p1, TYPE& p2) {
  TYPE tmp = p1;
  p1 = p2;
  p2 = tmp;
}

template<typename TYPE>
void swap(TYPE* p1, TYPE* p2) {
  TYPE tmp = *p1;
  *p1 = *p2;
  *p2 = tmp;
}

int main() {
  double a = 10;
  double b = 12;

  double* p1 = &a;
  double* p2 = &b;
  std::cout << "*p1: " << *p1 << ", *p2: " << p2 << std::endl;
// неявное инстанциирование
  swap(p1, p2);
  std::cout << "*p1: " << *p1 << ", *p2: " << p2 << std::endl;
  return 0;
}
```

## Специализация шаблонов

Можно _специализировать_, то есть изменять реализацию для определенных типов данных шаблон функции, отдельные методы шаблона класса или шаблон класса целиком.

При специализации функций и отдельных методов допускается только полная специализация. Перед определением специализации пишется `template <>`, а после имени функции или класса добавляется список аргументов основного шаблона в `<>`. Аналогичной функциональности можно добиться, если определить обычную функцию или перегрузить шаблон функции. Разница в том, что генерация кода для обычной функции будет происходить при компиляции её определения (т.е. всегда), а для шаблона и специализации – при первом использовании (инстанцировании).

Пример специализации шаблонов:

```cpp
template<typename TYPE>
void print(TYPE p) {
  std::cout << p.toString() << std::endl;
}
template<>
void print(int p) {
  std::cout << p << std::endl;
}
template<>
void print(float p) {
  std::cout << p << std::endl;
}
template<>
void print(std::string p) {
  std::cout << p << std::endl;
}
```

Пример использования специализации шаблонов для вычислений на этапе компиляции:

```cpp
#include <iostream>

template <size_t index>
size_t fibbonacci()
{
    return fibbonacci<index - 1>() + fibbonacci<index - 2>();
}

template <>
size_t fibbonacci<0>()
{
    return 0;
}

template <>
size_t fibbonacci<1>()
{
    return 1;
}

int main()
{
    std::cout << fibbonacci<10>() << std::endl;
    return 0;
}
```