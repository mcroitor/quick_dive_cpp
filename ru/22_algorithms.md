# Алгоритмы

- [Алгоритмы](#алгоритмы)
  - [Понятие алгоритма](#понятие-алгоритма)
    - [Функторы](#функторы)
    - [Предикаты](#предикаты)
    - [Правила именования алгоритмов в STL](#правила-именования-алгоритмов-в-stl)
  - [Алгоритмы, не меняющие данные](#алгоритмы-не-меняющие-данные)
    - [Поиск](#поиск)
    - [Подсчет](#подсчет)
    - [Сравнение](#сравнение)
  - [Алгоритмы, меняющие данные](#алгоритмы-меняющие-данные)
    - [Копирование](#копирование)
    - [Заполнение](#заполнение)
    - [Трансформация](#трансформация)
    - [Удаление](#удаление)
    - [Замена](#замена)
    - [сортировка](#сортировка)

## Понятие алгоритма

__Алгоритм это конечная последовательность действий, приводящая к желаемому результату.__

Реализации алгоритмов стандартной библиотеки С++ очень просты и эффективны. Поэтому было бы полезным уделить некоторое время на чтение исходников.

Все алгоритмы стандартной библиотеки шаблонов отделены от деталей реализации структур данных и используют в качестве параметров типы итераторов. Поэтому они могут работать с определяемыми пользователем структурами данных, когда эти структуры данных имеют типы итераторов, удовлетворяющие предположениям в алгоритмах.

Алгоритмы STL в основном оперируют с контейнерами, и в качестве параметров используют полуинтервалы итераторов.

### Функторы

__Функтором называется объект класса, в котором переопределен оператор "круглые скобки".__

В объявлении класса можно переопределить оператор `()`. Если этот оператор в классе переопределен, то объекты этого класса получают свойства функций \(их можно использовать как функции\). Такие объекты называются функциональными или функторами. Функторы удобно использовать, когда функция должна обладать "памятью", а также, как замена указателей на функции.

 > Иногда функциональным объектом называют указатель на функцию.

Пример функтора, который меняет значения двух целочисленных переменных и подсчитывает количество вызовов:

```cpp
class _swap{
    static size_t counter = 0;
    static void increment() { ++counter; }
public:
    _swap(){}
    void operator ()(int& a, int& b){
        int tmp = a;
        a = b;
        b = tmp;
        increment();
    }
    int getNrCalls() {return counter; }
};

int main() {
    _swap swap;
    int a = 3, b = 5;
    swap(a, b);
    return 0;
}
```

### Предикаты

__Предикатом называется функция, возвращающая логическое значение.__

Алгоритмы STL оперируют унарными и бинарными предикатами.

Пример предиката

```cpp
bool isOdd(int value) {
   return value % 2 == 0;
}
```

### Правила именования алгоритмов в STL

Для некоторых алгоритмов предусмотрены как оперативные версии \(то есть результат сохраняется в указаном итераторами сегменте\), так и копирующие версии. Решение, включать ли копирующую версию в библиотеку, было основано на рассмотрении эфективности алгоритма. Когда стоимость выполнения операции доминирует над стоимостью копии, копирующая версия не включена. Например, `sort_copy` не включена, так как стоимость сортировки намного значительнее, и пользователи могли бы также делать `copy` перед `sort`. 

Копирующая версия алгоритма `algorithm` называется `algorithm_copy` \(добавляется суффикс `_copy`\). В копирующих алгоритмах не указывается конец второго интервала, так как он может быть вычислен исходя их длины первого интервала.

Кроме того, для некоторых алгоритмов существуют предикатные версии. Алгоритмы, которые берут предикаты, оканчиваются суффиксом `_if` \(который следует за суффиксом `_copy` в случае копирующего алгоритма\).   
  
Класс `Predicate` используется всякий раз, когда алгоритм ожидает функциональный объект, при применении которого к результату разыменования соответствующего итератора возвращается значение, обратимое в `bool`. Другими словами, если алгоритм берёт `Predicate pred` как свой параметр и first как свой параметр итератора, он должен работать правильно в конструкции `if (pred(*first)) {...}`. Предполагается, что функциональный объект pred не применяет какую-либо непостоянную функцию для разыменованного итератора.   
  
Класс `BinaryPredicate` используется всякий раз, когда алгоритм ожидает функциональный объект, который при его применении к результату разыменования двух соответствующих итераторов или к разыменованию итератора и типа `T`, когда T - часть сигнатуры, возвращает значение, обратимое в `bool`. Другими словами, если алгоритм берёт `BinaryPredicate binary_pred` как свой параметр и `first1` и `first2` как свои параметры итераторов, он должен работать правильно в конструкции `if (binary_pred(*first, *first2)) {...}`. 

`BinaryPredicate` всегда берёт тип первого итератора как свой первый параметр, то есть в тех случаях, когда `T value` - часть сигнатуры, он должен работать правильно в контексте `if (binary_pred (*first, value)) {...}`. Ожидается, что `binary_pred` не будет применять какую-либо непостоянную функцию для разыменованных итераторов.

## Алгоритмы, не меняющие данные

Данные алгоритмы не изменяют коллекции с которыми работают.

### Поиск



### Подсчет

### Сравнение

## Алгоритмы, меняющие данные

Данные алгоритмы изменяют коллекции, с которыми работают, тем или иным способом, например, вставляют новые элементы, удаляют, меняют местами.

### Копирование

### Заполнение

### Трансформация

### Удаление

### Замена

### сортировка
