# объектно-ориентированное программирование

- [объектно-ориентированное программирование](#объектно-ориентированное-программирование)
  - [Понятие объектно-ориентированного программирования](#понятие-объектно-ориентированного-программирования)
    - [Абстракция данных](#абстракция-данных)
    - [Инкапсуляция](#инкапсуляция)
    - [Наследование](#наследование)
  - [Создание и разрушение объектов](#создание-и-разрушение-объектов)
  - [Виртуальные функции](#виртуальные-функции)
    - [Абстрактные классы](#абстрактные-классы)
    - [Интерфейс](#интерфейс)
  - [Полиморфизм](#полиморфизм)
  - [Библиография](#библиография)

## Понятие объектно-ориентированного программирования

__Объектно-ориентированное программирование__ (ООП) есть парадигма программирования, основанная на использовании объектов и классов. В данной парадигме всё является объектом или его частью, и в рамках ООП программа рассматривается как взаимодействие объектов.

Основными понятиями объектно-ориентированного программирования являются:

- __Класс__ – пользовательский тип данных, представляющий собой абстракцию объектов реального мира, включающий в себя набор данных, описывающих эти объекты, а также функций, описывающих поведение этих объектов;
- __Объект__ – переменная класса;
- __Интерфейс__ – (интерфейс класса) множество открытых свойств класса, его методов, а также функций с параметрами типа класса;

Класс можно рассматривать как множество объектов с описываемыми классом свойствами. В этом случае свойства определяются интерфейсом класса, а объект класса является элементом данного множества.

Основные принципы ООП:

- _абстракция данных_ - реализация только тех характеристик объекта, которые необходимы для решения задачи;
- _инкапсуляция_ - изоляция и сокрытие данных и методов класса;
- _наследование_ - возможность создания новых классов на основе уже существующих;
- _полиморфизм_ - механизм, позволяющий использовать данные различных типов в общем контексте.

### Абстракция данных

__Абстракция данных__ – это использование только тех характеристик объекта, которые с достаточной точностью представляют его в данной системе. Основная идея состоит в том, чтобы представить объект минимальным набором полей и методов и при этом с достаточной точностью для решаемой задачи.

Абстракция является основой объектно-ориентированного программирования и позволяет работать с объектами, не вдаваясь в особенности их реализации.

### Инкапсуляция

__Инкапсуляция__ – изоляция элементов, определяющих структуру (данные) и поведение (методы). Инкапсуляция предполагает разделение класса на интерфейс и реализацию.

Способы применения объекта определяются интерфейсом класса.

```cpp
class vector {
private:
    double x, y;
    void normalize();

public:
    void move(double, double);
    std::string to_string() const;
};

void print(const vector&);
```

В указанном примере класс `vector` инкапсулирует данные `x`, `y` и метод `normalize`. Интерфейс класса определяется методами `move`, `to_string` и функцией `print`.

### Наследование

__Наследование__ – один абстрактный тип данных может наследовать данные и функциональность другого типа данных.

Наследование способствует повторному использованию кода.

Класс, наследующий свойства другого класса, называется __дочерним__, __производным__ или __подклассом__.

Класс, производящий наследование в подклассах, называется __родительским классом__, __предком__, __родителем__ или __надклассом__.

Дочерние классы образуются из базовых за счет добавления в определение новых свойств и переопределения некоторых методов.

Пример наследования:

```cpp
class Animal {
    point position;
public:
    Animal();
    virtual ~Animal();

    virtual void eat() const {
        puts("do eat");
    }
    void move(point pt) {
        position = pt;
    }
};

class Cat: Animal {
public:
    Cat();
    virtual ~Cat();

    virtual void eat() const;
};

class Pig: Animal {
public:
    Pig();
    virtual ~Pig();

    virtual void eat() const;
}
```

В связи с тем, что производный класс описывает некоторое подмножество элементов базового класса, указатель (ссылка) на объект базового класса может ссылаться и на объект производного класса. Обратное утверждение неверно, то есть указатель (ссылка) на объект класса-потомка __не может__ ссылаться на объект базового класса.

Пример:

```cpp
class A {};
class B: public A {};

A a1;
B b1;
A& a = b1; // OK!
B& b = a1; // ERROR!
```

## Создание и разрушение объектов

Специальная функция, совпадающая по имени с названием класса, называется __конструктором__. Данная функция используется для создания объектов класса и инициализации их полей. Один класс может содержать несколько конструкторов, отличающихся по назначению (и параметрам):

- конструктор без параметров называется конструктором по умолчанию;
- конструктор, принимающий в качестве параметра объект того же типа, называется конструктором копирования.

Конструктор не возвращает значения.

Функция, совпадающая по имени с конструктором, но начиняющаяся с символом `~`, называется __деструктором__. Роль деструктора - правильное освобождение памяти при уничтожении объекта. Класс может иметь только один деструктор.

```cpp
class vector {
    double _x, _y, _z;
public:
    // конструктор по умолчанию
    vector();
    // конструктор с параметрами
    vector(double x, double y, double z);
    // конструктор копирования
    vector(const vector&);
    // деструктор
    ~vector();
};
```

Если в классе не определены конструкторы, то компилятор создает конструктор по умолчанию. Однако, при определении пользовательского конструктора компилятор не создает конструктор по умолчанию, поэтому в случае необходимости его использования его необходимо определить явно. Если достаточен конструктор, генерируемый компилятором, то можно использовать ключевое слово `default` для его определения. Этого же касается и конструктора копирования.

```cpp
class vector {
    double _x, _y, _z;
public:
    // конструктор по умолчанию
    vector() = default;
    // конструктор с параметрами
    vector(double x, double y, double z);
    // конструктор копирования
    vector(const vector&) = default;
    // деструктор
    ~vector();
}
```

Если в классе не определен деструктор, то компилятор создает деструктор по умолчанию.

При реализации конструктора с параметрами поля класса, обычно, инициализируются значениями параметров при помощи списка инициализации. Список инициализации представляет собой список параметров, разделенных запятыми, заключенных в фигурные скобки и инициализируемых значениями параметров.

```cpp
vector::vector(double x, double y, double z): _x(x), _y(y), _z(z) {}
```

## Виртуальные функции

Программист может переопределить (переписать) функцию базового класса в дочернем классе. Например, в следующих строках кода показана эта возможность:

```cpp
// nopoly.cpp
#include <cstdio>

struct A {
    A() {}
    void print() const { puts("A"); }
};

struct B: public A {
    B(){}
    void print() const { puts("B"); }
};

int main(){
     A* obj = new B;
     obj->print();
     obj = new A;
     obj->print();
     return 0; 
}
```

Однако, ожидаемый результат не будет достигнут - на экране  в обоих случаях будет напечатана буква A, а не B. Это связано с тем, что компилятор не может определить, какого типа является объект, находящийся в переменной obj, поэтому вызывается функция родительского объекта. Данная проблема может быть решена при помощи виртуальных функций. В случае использования виртуальных функций компилятор гарантирует вызов своего варианта функции для каждого объекта класса из иерархии.

Метод называется __виртуальным__, если он может быть переопределён в дочернем классе. Пример использования виртуальных функций:

```cpp
// poly01.cpp
#include <сstdio>

struct A {
     A() {}
     virtual void print() const { puts("A"); }
};

struct B:public A {
     B() {}
     virtual void print() const { puts("B"); }
};

int main(){
     A* obj = new B;
     obj->print();
     obj = new A;
     obj->print();
     return 0;
}

```

В примере _poly01.cpp_ мы получим желаемый результат: на экране будет напечатано "BA".

### Абстрактные классы

__Абстрактным методом__ (абстрактной член-функцией, чистой виртуальной функцией) называется виртуальная функция без реализации.

```cpp
struct Comparable {
    // чистая виртуальная функция!
    virtual bool equal(Comparable*) = 0; 
};

class Complex: Comparable {
    double real;
    double imaginary;
public:
    virtual bool equal(Comparable*); 
};
```

Если класс имеет хотя бы один абстрактный метод, то данный класс называется __абстрактным классом__.

### Интерфейс

Абстрактный класс может содержать только публичные чистые виртуальные функции. В этом случае иногда (по аналогии с другими языками ОО) этот класс называется интерфейсом.

## Полиморфизм

__Полиморфизм__ механизм, позволяющий использовать данные различных типов в общем контексте. Пример полиморфизма, основанного на неявном приведении типов:

```cpp
bool less(double x, double y) { return x < y; }

int a = 10, b = 15;
less(a, b);
```

Полиморфизм на основе виртуальных функций, называемый также динамическим полиморфизмом, основан на возможности указателя на объект базового класса включать в себя указатель на объект класса-потомка.

Данное свойство может быть использовано при реализации полиморфизма - возможности использования одной и той же функции (одного и того же имени функции) с различными типами параметров. Пример динамического полиморфизма с классами из показан в листинге _poly02.cpp_:

```cpp
// poly02.cpp
#include <сstdio>
​
struct A{
     A() {}
     virtual void print() const { puts("A"); }
};
​
struct B:public A{
     B(){}
     virtual void print() const { puts("B"); }
};

void print(const A& a){
     a->Print();
}

int main(){
     B b;
     A& obj = b;
     print(obj);
     return 0;
}
```

## Библиография

1. [Объектно-ориентированное программирование, Wikipedia](https://ru.wikipedia.org/wiki/Объектно-ориентированное_программирование)
2. [Страуструп Б. Язык программирования C++.](https://www.google.com/search?q=страуструп+язык+программирования+c%2B%2B&ie=UTF-8&oe=UTF-8)
3. [Classes, cppreference.com](https://en.cppreference.com/w/cpp/language/classes)
