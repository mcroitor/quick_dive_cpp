# Хорошие практики программирования

- [Хорошие практики программирования](#хорошие-практики-программирования)
  - [Стиль программирования](#стиль-программирования)
    - [Используйте понятные имена переменных, функций и классов](#используйте-понятные-имена-переменных-функций-и-классов)
    - [Используйте комментарии для пояснения кода](#используйте-комментарии-для-пояснения-кода)
    - [Используйте пробелы для улучшения читаемости кода](#используйте-пробелы-для-улучшения-читаемости-кода)
    - [Используйте отступы для выделения блоков кода](#используйте-отступы-для-выделения-блоков-кода)
    - [Используйте пустые строки для разделения логических блоков кода](#используйте-пустые-строки-для-разделения-логических-блоков-кода)
    - [Избегайте использования магических чисел и строк](#избегайте-использования-магических-чисел-и-строк)
    - [Избегайте использования длинных строк кода](#избегайте-использования-длинных-строк-кода)
    - [Избегайте функций слишком большого размера](#избегайте-функций-слишком-большого-размера)
  - [Документирование кода](#документирование-кода)
  - [Тестирование](#тестирование)
  - [Идиомы программирования](#идиомы-программирования)
    - [Базовые идиомы](#базовые-идиомы)
      - [Инкремент и декремент](#инкремент-и-декремент)
      - [Swap](#swap)
    - [RAII](#raii)
    - [Pimpl](#pimpl)
  - [Библиография](#библиография)

Хорошие практики программирования - это набор правил и рекомендаций, которые позволяют улучшить качество кода программы, упростить ее понимание и поддержку. Хорошие практики программирования включают в себя правила оформления кода, документирования кода, тестирования программы и использования идиом программирования.

Хорошие практики программирования включают в себя следующие аспекты:

1. Стиль программирования - правила оформления кода программы.
2. Документирование кода - добавление комментариев к коду программы.
3. Тестирование программы - проверка программы на соответствие требованиям.
4. Идиомы программирования - стандартные способы решения задач программирования.

## Стиль программирования

__Стилем программирования__ называются правила оформления кода программы. Стиль программирования определяет

1. требования к наименованиям переменных, функций и т.д.
2. правила форматирования кода;
3. правила организации кода;
4. правила документирования кода.

Стиль программирования позволяет улучшить читаемость кода, упростить его понимание и поддержку [^1]. Это особенно важно в командной разработке, когда над одним проектом работает несколько программистов или при передаче проекта от одного программиста другому.

Стиль программирования обычно определяется внутренними стандартами компании или сообщества программистов. Однако, существуют стандарты, которые широко применяются в индустрии программирования. Например, стандарты оформления кода для языка `C++` определены в книге C++ Coding Standards: 101 Rules, Guidelines, and Best Practices [^2] и в стандарте Google C++ Style Guide[^3].

В большинстве сред разработки реализованы инструменты, которые позволяют автоматически проверять код на соответствие стилю программирования. Настоятельно рекомендуется использовать такие инструменты для поддержания единого стиля программирования в проекте.

Ниже перечислены некоторые основные правила оформления кода:

1. Используйте понятные имена переменных, функций и классов
2. Используйте комментарии для пояснения кода
3. Используйте пробелы для улучшения читаемости кода
4. Используйте отступы для выделения блоков кода
5. Используйте пустые строки для разделения логических блоков кода
6. Избегайте использования магических чисел и строк
7. Избегайте использования длинных строк кода
8. Избегайте функций слишком большого размера

### Используйте понятные имена переменных, функций и классов

Имена переменных, функций и классов должны быть понятными и описательными. Имена должны отражать назначение переменной, функции или класса и быть понятными для других программистов. Для именования используют, обычно, один из следующих стилей:

1. `camelCase` - первое слово с маленькой буквы, каждое следующее слово с большой буквы: `myVariable`, `myFunction`. Обычно используется для именования переменных, функций и методов.
2. `snake_case` - все слова в нижнем регистре, разделены символом подчеркивания: `my_variable`, `my_function`, `my_class`. Такое именование обычно используется в стандартной библиотеке языка `C++`.
3. `PascalCase` - каждое слово с большой буквы: `MyClass`. Такое именование в `C++` обычно используется для именования классов и структур.
4. `UPPER_CASE` - все буквы в верхнем регистре, слова разделены символом подчеркивания: `MY_CONSTANT`. Используется для именования констант.

В других языках программирования могут использоваться другие стили именования.

### Используйте комментарии для пояснения кода

Качественный и чистый код обязательно содержит некоторую документацию, оформленную в виде комментариев. Комментарии помогают понять назначение кода, его особенности и логику работы. Важно не только пояснение кода, но и обоснование принятых решений, и указание дополнительной информации (например, автор, дата создания и т.д.).

### Используйте пробелы для улучшения читаемости кода

Когда мы пишем некоторый текст, мы разделяем слова пробелами, чтобы улучшить его читаемость. То же самое касается и кода программы: расстановка пробелов между операторами, ключевыми словами и переменными улучшает читаемость кода и упрощает его понимание.

Плохо писать:

```cpp
int a=5;
```

Гораздо лучше писать:

```cpp
int a = 5;
```

### Используйте отступы для выделения блоков кода

Отступы в виде пробелов или табуляции используются для выделения блоков кода и улучшения его читаемости. Отступы позволяют легко определить вложенность блоков кода и упростить его понимание.

Плохо писать:

```cpp
for (int i = 0; i < 10; i++) {
std::cout << i << std::endl;
}
```

Гораздо лучше писать:

```cpp
for (int i = 0; i < 10; i++) {
    std::cout << i << std::endl;
}
```

Кроме того, отступы позволяют выделить логические блоки кода, которые могут быть кандидатами на выделение в отдельные функции.

### Используйте пустые строки для разделения логических блоков кода

Сложный последовательный код обычно содержит несколько логических блоков, которые выполняют разные задачи. Для улучшения читаемости кода и его понимания логические блоки кода следует разделять пустыми строками.

Плохо писать:

```cpp
int a = 5;
int b = 10;
int c = a + b;
std::cout << c << std::endl;
```

Гораздо лучше писать:

```cpp
int a = 5;
int b = 10;
int c = a + b;

std::cout << c << std::endl;
```

### Избегайте использования магических чисел и строк

_Магическими числами_ и _магическими строками_ называются числа и строки, которые используются в коде напрямую, без объявления в виде констант. Использование магических чисел и строк затрудняет понимание кода и его поддержку, так как не понятно, что означают эти числа и строки. Поэтому, магические числа и строки следует заменять на константы с понятными именами.

Плохо писать:

```cpp
if (status == 1) {
    // ...
}
```

Гораздо лучше писать:

```cpp
const int STATUS_OK = 1;

if (status == STATUS_OK) {
    // ...
}
```

### Избегайте использования длинных строк кода

У длинных строк кода та же проблема: плохая читаемость, например, из-за того что они не помещаются на экране. Поэтому, длинные строки кода следует разбивать на несколько строк с помощью переноса строки или разделения на несколько строк с помощью оператора конкатенации.

Плохо писать:

```cpp
std::string longString = "This is a very long string that does not fit on the screen and is hard to read.";
```

Гораздо лучше писать:

```cpp
std::string longString = "This is a very long string that does not fit on the screen "
                         "and is hard to read.";
```

### Избегайте функций слишком большого размера

Функции слишком большого размера также сложно читать и понимать. Более того, длинная функция из-за сложности своей структуры может быть сложна для тестирования и поддержки. Поэтому, функции следует разбивать на более мелкие функции, каждая из которых выполняет одну конкретную задачу.

## Документирование кода

Документирование кода - это процесс добавления комментариев к коду программы для объяснения его работы и назначения. Документирование кода позволяет улучшить понимание кода, упростить его поддержку и разработку. На базе документированного кода специальные программы могут автоматически генерировать документацию к программе, а среды разработки могут предоставлять подсказки и дополнительную информацию о коде.

Документирование кода обычно включает в себя следующие виды комментариев:

1. Комментарии к классам, функциям и переменным - описывают назначение и особенности класса, функции или переменной.
2. Комментарии к блокам кода - позволяют объяснить логику работы блока кода.
3. Комментарии к строкам кода - обосновывают принятые решения и объясняют сложные участки кода.
4. Метаданные - информация о версии, авторе, дате создания и т.д.

Избыточное документирование кода также может быть вредно, так как усложняет понимание кода и увеличивает объем кода. Поэтому, документирование кода должно быть умеренным и информативным.

Для создания технической документации к программе обычно используются специальные инструменты, такие как Doxygen [^4], Javadoc [^5] и т.д. Эти инструменты позволяют автоматически генерировать документацию к программе на основе комментариев в коде.

Для определения стандартов документирования кода обычно используются стандарты оформления кода, такие как Google C++ Style Guide[^3].

Пример документирования функции на `C++`:

```cpp
/**
 * @brief This is a brief description of the function.
 *
 * This is a detailed description of the function.
 *
 * @param[in] a The first parameter.
 * @param[in] b The second parameter.
 * @return The result of the function.
 */
int add(int a, int b) {
    return a + b;
}
```

Пример документирования класса на `C++`:

```cpp
/**
 * @brief This is a brief description of the class.
 *
 * This is a detailed description of the class.
 */
class MyClass {
public:
    /**
     * @brief This is a brief description of the function.
     *
     * This is a detailed description of the function.
     *
     * @param[in] a The first parameter.
     * @param[in] b The second parameter.
     * @return The result of the function.
     */
    int add(int a, int b);
};
```

Документация к коду определяется блочным комментарием, начинающимся с `/**` и заканчивающимся `*/`. В комментарии могут использоваться специальные теги, которые позволяют автоматически генерировать документацию к программе.

Некоторые основные теги документации:

1. `@brief` - краткое описание.
2. `@param` - описание параметра функции.
3. `@return` - описание возвращаемого значения функции.
4. `@version` - версия функции или класса.
5. `@author` - автор функции или класса.
6. `@date` - дата создания функции или класса.

## Тестирование

Одной из проблем информатики является обоснование корректности программы. Тестирование программы - это процесс проверки программы на соответствие требованиям и обнаружение ошибок. Тестирование программы позволяет убедиться в том, что программа работает правильно и не содержит ошибок.

Существует несколько видов тестирования программы:

1. Модульное тестирование (en. _unit testing_) - тестирование отдельных модулей программы (функций, классов и т.д.).
2. Интеграционное тестирование (en. _integration testing_) - тестирование взаимодействия между модулями программы.
3. Системное тестирование (en. _system testing_) - тестирование всей программы в целом.
4. Приемочное тестирование (en. _acceptance testing_) - тестирование программы заказчиком.
5. Регрессионное тестирование (en. _regression testing_) - тестирование программы после внесения изменений.
6. Тестирование производительности (en. _performance testing_) - тестирование производительности программы.
7. Тестирование безопасности (en. _security testing_) - тестирование безопасности программы.

По Кенту Беку [^6] написание модульных тестов (unit-тестов) является обязанностью разработчика. Модульные тесты позволяют убедиться в корректности работы отдельных модулей программы и обнаружить ошибки на ранних стадиях разработки. Модульные тесты обычно пишутся вместе с кодом программы (а иногда и перед написанием кода) и выполняются автоматически при сборке проекта.

Для написания модульных тестов обычно используются специальные фреймворки для тестирования, такие как Google Test [^7], Catch2 [^8] и т.д. Эти фреймворки позволяют удобно писать и запускать тесты, а также автоматически проверять результаты тестирования.

Впрочем, написать простейший тест можно и без использования фреймворка. Например, для тестирования функции сложения двух чисел можно написать следующий тест:

```cpp
#include <cassert>

int add(int a, int b) {
    return a + b;
}

int main() {
    assert(add(2, 3) == 5);
    assert(add(-2, 3) == 1);
    assert(add(0, 0) == 0);

    return 0;
}
```

## Идиомы программирования

Идиомой программирования называется стандартный способ написания кода, который является наиболее эффективным и удобным для решения определенной задачи. Идиомы программирования обычно являются частью языка программирования и включают в себя стандартные шаблоны, алгоритмы и структуры данных. Идиомы программирования можно назвать низкоуровневыми паттернами проектирования[^9], которые используются для решения конкретных задач.

### Базовые идиомы

#### Инкремент и декремент

Одной из стандартных задач программирования является подсчет (элементов, выполненных операций и т.д.). Стандартное решение этой задачи является введение переменной - счетчика и увеличение (уменьшение) ее значения на единицу. В ряде языков для этого используется форма:

```basic
i = i + 1
```

В `C`-подобных языках для этой задачи используется оператор инкремента `++`:

```cpp
i++;
```

Соответственно, для уменьшения значения переменной используется оператор декремента `--`:

```cpp
i--;
```

#### Swap

Одной из типичных задач программирования является обмен значениями двух переменных. Стандартное решение этой задачи заключается в использовании третьей переменной:

```cpp
template <typename T>
void swap(T& a, T& b) {
    T tmp = a;
    a = b;
    b = tmp;
}
```

Однако, если необходимо обменять значения двух контейнеров, поэлементный обмен значений является неэффективным. Обычно, контейнер содержит в себе указатель на управляемую им память, поэтому обмен указателей является более эффективным решением:

```cpp
template <typename T>
void swap(T* a, T* b) {
    T* tmp = a;
    a = b;
    b = tmp;
}
```

### RAII

_RAII_ (Resource Acquisition Is Initialization) - это идиома программирования, которая заключается в том, что ресурсы должны быть выделены в конструкторе объекта и освобождены в деструкторе. Это позволяет гарантировать, что ресурсы будут освобождены в случае исключения или выхода из блока.

Пример реализации RAII для работы с файлами представлен ниже:

```cpp
class File {
public:
    File(const std::string& filename) : file(fopen(filename.c_str(), "r")) {
        if (!file) {
            throw std::runtime_error("Failed to open file");
        }
    }

    ~File() {
        fclose(file);
    }

    void read() {
        // ...
    }

private:
    FILE* file;
};
```

### Pimpl

_Pimpl_ (Pointer to Implementation) - это идиома программирования, которая заключается в том, что реализация класса выносится в отдельный класс, который хранится в умном указателе в основном классе. Это позволяет скрыть реализацию класса от клиента и уменьшить зависимость между интерфейсом и реализацией.

```cpp
class Widget {
public:
    Widget();
    ~Widget();

    void doSomething();

private:
    class Impl;
    std::unique_ptr<Impl> impl;
};

class Widget::Impl {
public:
    void doSomething() {
        // ...
    }
};

Widget::Widget() : impl(std::make_unique<Impl>()) {}

Widget::~Widget() = default;

void Widget::doSomething() {
    impl->doSomething();
}
```

## Библиография

[^1]: [Керниган Б., Пайк Р., Практика программирования, Вильямс, 2019](https://www.google.com/search?q=Керниган+Пайк+Практика+программирования)
[^2]: [Sutter H., Alexandrescu A., C++ Coding Standards: 101 Rules, Guidelines, and Best Practices, Pearson Education, 2004](https://www.google.com/search?q=C%2B%2B+Coding+Standards%3A+101+Rules%2C+Guidelines%2C+and+Best+Practices)
[^3]: [Google C++ Style Guide, Google, github.io](https://google.github.io/styleguide/cppguide.html)
[^4]: [Doxygen, doxygen.nl](https://www.doxygen.nl)
[^5]: [Javadoc, Oracle](https://www.oracle.com/java/technologies/javase/javadoc.html)
[^6]: [Бек Кент, Экстремальное программирование. Разработка через тестирование, Питер, 2020](https://www.google.com/search?q=Бек+Кент+Экстремальное+программирование.+Разработка+через+тестирование)
[^7]: [Google Test, Google, github.com](https://github.com/google/googletest)
[^8]: [Catch2, catchorg, github.com](https://github.com/catchorg/Catch2)
[^9]: [Паттерны программирования, Wikipedia](https://ru.wikipedia.org/wiki/Шаблон_проектирования)
