# Проект. Системы сборки проектов.

- [Проект. Системы сборки проектов.](#проект-системы-сборки-проектов)
  - [Организация проекта](#организация-проекта)
  - [Компиляция из командной строки](#компиляция-из-командной-строки)
  - [Системы сборки проектов](#системы-сборки-проектов)
    - [make](#make)
    - [Ninja](#ninja)
    - [Autotools](#autotools)
    - [CMake](#cmake)
  - [Устройство Makefile](#устройство-makefile)
  - [Ссылки](#ссылки)

## Организация проекта

Под проектом понимается совокупность исходных файлов, распределенных каким-то образом по каталогам проекта. 

Проект может содержать один проектный файл или несколько, для построения из исходных файлов чего-либо, что может считаться целью проекта. Целью проекта может быть статическая библиотека, динамическая библиотека, исполнимый файл или совокупность библиотек и исполнимых файлов.

Проект может состоять из нескольких подпроектов. Подпроект — это исходные (и не только) тексты другого проекта, добавленные в структуру каталогов проекта.

Также проект может включать в себя сторонние модули: внешние зависимости (например, библиотеки).

Организация исходного кода в проекте может быть самой разнообразной, однако, главной идеей является разделение 

* исходного кода проекта
* подпроектов
* ресурсов проекта
* модулей
* результата сборки
* временных файлов
* документации

с целью упрощения работы с проектом.

Возможный вариант структуры в стиле Linux:

* `bin` - хранит результат сборки проекта 
* `include` - заголовочные файлы
* `src` - файлы `cpp`
* `lib` - внешние зависимости (библиотеки)
* `obj` - временные файлы, создаваемые в процессе сборки проекта
* `resources` - ресурсы, используемые приложением (изображения, аудио, видео, и т.д.)

Каждая IDE предлагает свою структуру проекта.

## Компиляция из командной строки

Конечно, сейчас нет необходимости уметь компилировать приложение в командной строке, потому что современные среды программирования идут в нагрузку с компилятором, и весь запуск процесса сборки занимает выбор пункта меню или нажатие комбинации клавиш. Однако, в рамках общего развития полезно знать, как же это всё-таки делается - собирается приложение из исходных файлов, тем более что это совсем нередкая ситуация для пользователей ОС Linux.

Любое приложение консольного типа может запускаться с набором ключей \(параметров\). Для того, чтобы знать, какие ключи может принимать это приложение, необходимо запустить его с ключом `--help` или `-h`, в зависимости уже от реализации самого приложения. Например, об использовании компилятора `GNU C++` можно узнать, выполнив следующую команду:

```shell
gcc --help
```

Чтобы скомпилировать файл `main.cpp` в файл `file[.exe]`  достаточно написать следующую строку:

```shell
gcc main.cpp -o file -l stdc++
```

На самом деле можно попробовать запустить компиляцию файла только с указанием имени файла, но в этом случае компиляция будет успешна только в случае если программа использует только стандартную библиотеку С, а полученный исполняемый файл будет называться `a[.exe]`. Поэтому ключ __-o__ указывает, как будет называться выходной файл, то есть __file__. Ключ `-l` указывает, что к сборке результата необходимо добавить стандартную библиотеку С++. По правилам подключения библиотек программирования в ОС Linux, если файл библиотеки называется `libfilename.a`, то для подключения достаточно прописать `-l filename`, либо указать полное имя библиотеки.

Между ключом и значением можно не ставить пробел, то есть записать предыдущую команду можно следующим образом:

```shell
gcc main.cpp -ofile -lstdc++
```

Если проект приложения состоит из нескольких файлов, то для сборки приложения можно указать все компилируемые файлы:

```shell
gcc first.cpp second.cpp main.cpp -o file -lstdc++
```

_Помните, что заголовочные файлы не компилируются!_

Однако можно скомпилировать каждый файл в объектный, после чего из полученных файлов собрать приложение. В этом случае процесс сборки приложения в командной строка будет выглядеть следующим образом:

```shell
gcc first.cpp -o fisrt.o -O2 -c -std=c++14
gcc second.cpp -o second.o -O2 -c -std=c++14
gcc main.cpp -o main.o -O2 -c -std=c++14
gcc first.o second.o main.o -o file -lstdc++ -love
```

_Перечисление подключаемых библиотек всегда надо указывать последними в команде сборки._

Выполнять компиляцию каждого файла и сборку приложения - это становится утомительной процедурой. Поэтому для автоматизации данного процесса используют различные системы сборки проектов.

## Системы сборки проектов

Автоматизация сборки — этап процесса разработки программного обеспечения, заключающийся в автоматизации широкого спектра задач, решаемых программистами в их повседневной деятельности.

Включает такие действия, как:

* компиляция исходного кода в объектный модуль,
* сборка бинарного кода в исполняемый файл,
* выполнение тестов,
* развёртывание программы в целевой среде,
* Написание сопроводительной документации или описание изменений новой версии,
* Конфигурация и подготовка файлов к сборке,
* Сбор и передача информации итоговой программе (версия программы, системы, компилятора, аппаратная информация, системная информация, лицензия программы, имя автора и т. п.).

Основное средство автоматизации сборки — применение специализированного инструмента; один из ранних и исторически значимых инструментов является утилита `make`, во многом определившая стиль и методы для инструментов, появившихся позднее. Один из таких элементов — формат `Makefile`, поддерживаемый в большинстве широко используемых инструментов (`Automake`, `CMake`, `imake`, `qmake`, `nmake`, `wmake`, `Apache Ant`, `Apache Maven`, `OpenMake Meister`, `Gradle`). Ключевые требования, предъявляемые средствам автоматизации — поддержка технологий непрерывной интеграции, в частности, постоянных "ночных сборок", управление зависимостями исходного кода, обеспечение разностной сборки, уведомление при совпадении исходного кода (после сборки) с имеющимися двоичными файлами, предоставление удобных отчётов о результатах компиляции и компоновки, автоматический запуск тестов и условное выполнение в зависимости от результатов прохождения.

Виды автоматизации, применяемые в различных инструментах:

* автоматизация по запросу (on-demand automation): запуск пользователем сценария в командной строке,
* запланированная автоматизация (scheduled automation): непрерывная интеграция, происходящая в виде ночных сборок,
* условная автоматизация (triggered automation): непрерывная интеграция, выполняющая сборку при каждом подтверждении изменения кода (commit) в системе управления версиями.

### make

`make` - утилита, автоматизирующая процесс преобразования файлов из одной формы в другую. Чаще всего это компиляция исходного кода в объектные файлы и последующая компоновка в исполняемые файлы или библиотеки.

Утилита использует специальные make-файлы, в которых указаны зависимости файлов друг от друга и правила для их удовлетворения. На основе информации о времени последнего изменения каждого файла Make определяет и запускает необходимые программы.

### Ninja

`Ninja` - это кроссплатформенная консольная утилита, представляющая из себя систему сборки программного обеспечения из исходного кода. Утилита Ninja была разработана Эваном Мартином, сотрудником компании Google.

Ninja представляет собой улучшенную и доработанную версию утилиты Make. Главная цель которой — автоматизация сборки и её ускорение, а также ускорение последующих пересборок, на основе сгенерированных утилитой файлов и решение типовых проблем при кроссплатформенной разработке.

### Autotools

`Autotools` - это система сборки проекта GNU, набор программных средств, предназначенных для поддержки переносимости исходного кода программ между UNIX-подобными системами.

Перенос кода с одной системы на другую может оказаться непростой задачей. Различные реализации компилятора языка Си могут существенно различаться: некоторые функции языка могут отсутствовать, иметь другое имя или находиться в разных библиотеках. Программист может решить эту задачу, используя макросы и директивы препроцессора, например `#if`, `#ifdef` и прочие. Но в таком случае пользователь, компилирующий программу на своей системе, должен будет определить все эти макросы, что не так просто, поскольку существует множество разных дистрибутивов и вариаций систем. Autotools вызываются последовательностью команд `./configure && make && make install` и решают эти проблемы автоматически.

Система сборки `GNU Autotools` широко используется во многих проектах с открытым исходным кодом. `GNU Autotools` включает в себя:

* `Autoconf` - утилита, генерирующая файл `configure` на базе файла `configure.ac` ( или `configure.in`). Созданный файл запускается пользователем, в результате чего скрипт проверяет особенности системы и создает `Makefile`.
* `Automake` - читает файлы Makefile.am и создаёт переносимый Makefile, то есть Makefile.in, который затем после обработки скриптом конфигурации становится Makefile и используется утилитой make.
* `Libtool` - управляет созданием библиотек в Unix-подобных операционных системах.

### CMake

`CMake` - кроссплатформенное программное средство автоматизации сборки программного обеспечения из исходного кода. Не занимается непосредственно сборкой, а лишь генерирует файлы сборки из предварительно написанного файла сценария `CMakeLists.txt` и предоставляет простой единый интерфейс управления. Помимо этого, способно автоматизировать процесс установки и сборки пакетов.

Считается альтернативой распространённой в сообществе GNU системе `Autotools`, разработанной на базе Perl и M4, основными недостатками которой считаются необходимость нетривиальных навыков для практического использования и несовместимость версий в ряде случаев.

## Устройство Makefile

Для использования системы сборки `make` необходимо создать файл `Makefile`.

Правила написания `Makefile` следующие:

* каждый элемент документа есть структура 

```makefile
<правило> : [<зависимость> [...]]
    [<команда>]
```

* каждая зависимость это определенная в документе `Makefile` цель или имя файла.
* Целью может быть имя получаемого файла.
* Цель может иметь несколько зависимостей, или не иметь вовсе. Если цель имеет зависимости, то сначала выполняются они, в том порядке, как они перечислены, а потом команда цели.


```makefile
all: file

file: first.o second.o main.o
    gcc first.o second.o main.o -o file -lstdc++ -love
    
first.o: first.cpp
    gcc -c first.cpp -O2 -std=c++14 -o first.o

second.o: second.cpp
    gcc -c second.cpp -O2 -std=c++14 -o second.o

main.o: main.cpp
    gcc -c main.cpp -O2 -std=c++14 -o main.o
```

В рамках файла сборки можно определять переменные, что позволяет `Makefile` делать более настраиваемым. Например, в в следующем примере сначала определены компилятор, выходной файл и флаги компиляции и сборки. Это позволяет легко настраивать процесс сборки программы.

```makefile
CC = gcc
CXXFLAGS = -O2 -std=c++14
LDFLAGS = -lstdc++ -love
OUT = file

all: file

file: first.o second.o main.o
    $(CC) first.o second.o main.o -o $(OUT) $(LDFLAGS)
    
first.o: first.cpp
    $(CC) -c first.cpp $(CXXFLAGS) -o first.o

second.o: second.cpp
    $(CC) -c second.cpp $(CXXFLAGS) -o second.o

main.o: main.cpp
    $(CC) -c main.cpp $(CXXFLAGS) -o main.o
```

Пример `Makefile` с дополнительными правилами:

```makefile
CC = gcc
CXXFLAGS = -O2 -std=c++14
LDFLAGS = -lstdc++ -love
OUT = file

BINDIR = bin
SRCDIR = src
OBJDIR = obj

all: prepare $(OUT)

prepare:
   mkdir -p $(OBJDIR) $(BINDIR)

clean:
   rm -f $(OBJDIR)/*.o $(BINDIR)/*

help:
   @echo Usage:
   echo make - build application
   echo make clean - remove build artifacts
   echo make help - show help

$(OUT): $(OBJDIR)/first.o $(OBJDIR)/second.o $(OBJDIR)/main.o
    $(CC) $(OBJDIR)/first.o $(OBJDIR)/second.o $(OBJDIR)/main.o -o $(BINDIR)/$(OUT) $(LDFLAGS)
    
$(OBJDIR)/first.o:
    $(CC) -c $(SRCDIR)/first.cpp $(CXXFLAGS) -o $(OBJDIR)/first.o

$(OBJDIR)/second.o:
    $(CC) -c $(SRCDIR)/second.cpp $(CXXFLAGS) -o $(OBJDIR)/second.o

$(OBJDIR)/main.o:
    $(CC) -c $(SRCDIR)/main.cpp $(CXXFLAGS) -o $(OBJDIR)/main.o
```

Сборка проекта выполняется запуском утилиты `make`. В этом случае выполняется первое определенное правило. Также можно запустить конкретное правило из `Makefile`, для этого необходимо указать это правило в качестве параметра. Например, очистка проекта для последнего `Makefile` будет выполняться командой `make clean`.

## Ссылки

1. [GNU make](https://www.gnu.org/software/make/)
2. [Ninja](https://ninja-build.org/)
3. [Autoconf](https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.71/autoconf.html)
4. [CMake](https://cmake.org)