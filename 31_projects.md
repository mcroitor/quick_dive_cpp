# Проект. Системы сборки проектов.

- [Проект. Системы сборки проектов.](#проект-системы-сборки-проектов)
  - [Компиляция файла из командной строки](#компиляция-файла-из-командной-строки)
  - [Организация проекта](#организация-проекта)
  - [Системы сборки проектов](#системы-сборки-проектов)
    - [autotools](#autotools)
    - [nmake](#nmake)
    - [Ninja](#ninja)
    - [CMake](#cmake)
    - [make](#make)

## Компиляция файла из командной строки

Конечно, сейчас нет необходимости уметь компилировать приложение в командной строке, потому что современные среды программирования идут в нагрузку с компилятором, и весь запуск процесса сборки занимает выбор пункта меню или нажатие комбинации клавиш. Однако, в рамках общего развития полезно знать, как же это всё-таки делается - собирается приложение из исходных файлов, тем более что это совсем нередкая ситуация для пользователей ОС Linux.

Любое приложение консольного типа может запускаться с набором ключей \(параметров\). Для того, чтобы знать, какие ключи может принимать это приложение, необходимо запустить его с ключом --help или -h, в зависимости уже от реализации самого приложения. Например, об использовании компилятора GNU C++ можно узнать, выполнив следующую команду:

```bash
gcc --help
```

Чтобы скомпилировать файл main.cpp в файл file\[.exe\]  достаточно написать следующую строку:

```bash
gcc main.cpp -o file -l stdc++
```

На самом деле можно попробовать запустить компиляцию файла только с указанием имени файла, но в этом случае компиляция будет успешна только в случае если программа использует только стандартную бублиотеку С, а полученный исполняемый файл будет называться a\[.exe\]. Поэтому ключ **-o** указывает, как будет называться выходной файл, то есть **file**. Ключ -l указывает, что к сборке результата необходимо добавить стандартную библиотеку С++. По правилам подключения библиотек программирования в ОС Linux, если файл библиотеки называется libfilename.a, то для подключения достаточно прописать -l filename. Либо указать полное имя библиотеки.

Кстати, между ключом и значением можно не ставить пробел, то есть записать предыдущую команду можно следующим образом:

```bash
gcc main.cpp -ofile -lstdc++
```

Если проект приложения состоит из нескольких файлов, то для сборки приложения можно указать все компилируемые файлы:

```bash
gcc first.cpp second.cpp main.cpp -o file -lstdc++
```

_**Помните, что заголовочные файлы не комилируются!**_

Однако можно скомпилировать каждый файл в объектный, после чего из полученных файлов собрать приложение. В этом случае процесс сборки приложения в командной строка будет выглядеть следующим образом:

```bash
gcc first.cpp -o fisrt.o -O2 -c -std=c++14
gcc second.cpp -o second.o -O2 -c -std=c++14
gcc main.cpp -o main.o -O2 -c -std=c++14
gcc first.o second.o main.o -o file -lstdc++ -love
```

## Организация проекта

## Системы сборки проектов

Выполнять компиляцию каждого файла и исборку приложения - это становится утомительной процедурой. Поэтому для автоматизации данного процесса используют системы сборки проектов.

### autotools

### nmake

### Ninja

### CMake

### make

Одной из старейших и простейших систем сборки проектов является **make**. Для работы системы программист определяет правила сборки в файле **Makefile** \(файл сборки\). Ниже приведен листинг _Makefile.01,_ эквивалентный по функциональности вышеприведеным командам.

```makefile
# Makefile.01
all: file

file: first.o second.o main.o
    gcc first.o second.o main.o -o file -lstdc++ -love
    
first.o: first.cpp
    gcc -c first.cpp -O2 -std=c++14

second.o: second.cpp
    gcc -c second.cpp -O2 -std=c++14

main.o: main.cpp
    gcc -c main.cpp -O2 -std=c++14

```

Правила написания _Makefile_ следующие:

* каждый элемент документа есть структура 

```makefile
<цель> : [<зависимость> [...]]
    [<команда>]
```

* каждая зависимость это определенная в документе _Makefile_ цель или имя файла.
* Целью может быть имя получаемого файла.
* Цель может иметь несколько зависимостей, или не иметь вовсе. Если цель имеет зависимости, то сначала выполняются они, в том порядке, как они перечислены, а потом команда цели.

В рамках файла сборки можно определять переменные, что позволяет _Makefile_ делать более настраиваемым. Например, в _Makefile.02_ сначала определены компилятор, выходной файл и флаги компиляции и сборки. Это позволяет легко настраивать процесс сборки программы.

```makefile
# Makefile.02
CC = gcc
CXXFLAGS = -O2 -std=c++14
LDFLAGS = -lstdc++ -love
OUT = file

all: file

file: first.o second.o main.o
    $(CC) first.o second.o main.o -o $(OUT) $(LDFLAGS)
    
first.o: first.cpp
    $(CC) -c first.cpp $(CXXFLAGS)

second.o: second.cpp
    $(CC) -c second.cpp $(CXXFLAGS)

main.o: main.cpp
    $(CC) -c main.cpp $(CXXFLAGS)
```
