# Проект. Системы сборки проектов

- [Проект. Системы сборки проектов](#проект-системы-сборки-проектов)
  - [Организация проекта](#организация-проекта)
  - [Понятие компиляции](#понятие-компиляции)
  - [Компиляция из командной строки](#компиляция-из-командной-строки)
  - [Системы сборки проектов](#системы-сборки-проектов)
    - [make](#make)
    - [Ninja](#ninja)
    - [Autotools](#autotools)
    - [CMake](#cmake)
  - [Устройство Makefile](#устройство-makefile)
  - [Пример универсального Makefile](#пример-универсального-makefile)
  - [Библиография](#библиография)

## Организация проекта

Под проектом понимается совокупность исходных файлов, распределенных каким-то образом по каталогам проекта.

Проект может содержать один проектный файл или несколько, для построения из исходных файлов чего-либо, что может считаться целью проекта. Целью проекта может быть статическая библиотека, динамическая библиотека, исполнимый файл или совокупность библиотек и исполнимых файлов.

Проект может состоять из нескольких подпроектов. Подпроект — это исходные (и не только) тексты другого проекта, добавленные в структуру каталогов проекта.

Также проект может включать в себя сторонние модули: внешние зависимости (например, библиотеки).

Организация исходного кода в проекте может быть самой разнообразной, однако, главной идеей является разделение

- исходного кода проекта
- подпроектов
- ресурсов проекта
- модулей
- результата сборки
- временных файлов
- документации

с целью упрощения работы с проектом.

Возможный вариант структуры в стиле Linux:

- `bin` - хранит результат сборки проекта
- `include` - заголовочные файлы
- `src` - файлы `cpp`
- `lib` - внешние зависимости (библиотеки)
- `obj` - временные файлы, создаваемые в процессе сборки проекта
- `resources` - ресурсы, используемые приложением (изображения, аудио, видео, и т.д.)

Каждая IDE предлагает свою структуру проекта.

## Понятие компиляции

__Компиляция приложения__ - это процесс преобразования исходного кода программы в исполняемый файл. В процессе компиляции исходный код программы преобразуется в объектные файлы, которые затем компонуются в исполняемый файл.

__Компилятор__ - это программа, которая выполняет компиляцию исходного кода программы. Компилятор преобразует исходный код программы в объектные файлы.

__Объектный файл__ - это файл, содержащий машинный код, эквивалентный исходному коду программы.

Процесс компиляции программы включает в себя следующие этапы:

- `препроцессирование` - предварительная обработка исходного кода программы, включая директивы препроцессора. В результате препроцессирования в исходный код программы могут быть вставлены содержимое файлов, объявленных директивой `#include`, а также могут быть удалены комментарии и обработаны директивы препроцессора;
- `компиляция` - преобразование исходного кода программы в объектные файлы. В результате компиляции исходный код программы преобразуется в объектные файлы, содержащие машинный код, который будет выполнен процессором;
- `компоновка` - объединение объектных файлов в исполняемый файл.

## Компиляция из командной строки

Конечно, сейчас нет необходимости уметь компилировать приложение в командной строке, потому что современные среды программирования идут в нагрузку с компилятором, и весь запуск процесса сборки занимает выбор пункта меню или нажатие комбинации клавиш. Однако, в рамках общего развития полезно знать, как же это всё-таки делается - собирается приложение из исходных файлов, тем более что это совсем нередкая ситуация для пользователей ОС Linux.

Любое приложение консольного типа может запускаться с набором ключей \(параметров\). Для того, чтобы знать, какие ключи может принимать это приложение, необходимо запустить его с ключом `--help` или `-h`, в зависимости уже от реализации самого приложения. Например, об использовании компилятора `GNU C++` можно узнать, выполнив следующую команду:

```shell
g++ --help
```

Чтобы скомпилировать файл `main.cpp` в файл `file[.exe]`  достаточно написать следующую строку:

```shell
g++ main.cpp -o file -l filename
```

На самом деле можно попробовать запустить компиляцию файла только с указанием имени файла, но в этом случае компиляция будет успешна только в случае если программа использует только стандартную библиотеку С, а полученный исполняемый файл будет называться `a[.exe]`. Поэтому ключ `-o` указывает, как будет называться выходной файл, то есть `file`. Ключ `-l` указывает, что к сборке результата необходимо добавить стандартную библиотеку С++. По правилам подключения библиотек программирования в ОС Linux, если файл библиотеки называется `libfilename.a`, то для подключения достаточно прописать `-l filename`, либо указать полное имя библиотеки.

Между ключом и значением можно не ставить пробел, то есть записать предыдущую команду можно следующим образом:

```shell
g++ main.cpp -ofile
```

Если проект приложения состоит из нескольких файлов, то для сборки приложения можно указать все компилируемые файлы:

```shell
g++ first.cpp second.cpp main.cpp -o file
```

> [!TIP]
> Заголовочные файлы не указываются в команде компиляции, так как компилятор сам ищет их в папке проекта.

Однако можно скомпилировать каждый файл в объектный, после чего из полученных файлов собрать приложение. В этом случае процесс сборки приложения в командной строка будет выглядеть следующим образом:

```shell
g++ first.cpp -o first.o -O2 -c -std=c++14
g++ second.cpp -o second.o -O2 -c -std=c++14
g++ main.cpp -o main.o -O2 -c -std=c++14
g++ first.o second.o main.o -o file -love
```

> [!TIP]
> Перечисление подключаемых библиотек всегда указывается на этапе компоновки объектных файлов в исполняемый файл.

Наиболее часто используемые ключи компиляции приведены в таблице:

| __Ключ__ | __Описание__ |
| -------- | ------------ |
| `-o`     | указание имени выходного файла |
| `-E`     | препроцессирование исходного файла |
| `-S`     | компиляция исходного файла в ассемблерный файл |
| `-c`     | компиляция исходного файла в объектный файл |
| `-g`     | генерация отладочной информации |
| `-O<N>`    | уровень оптимизации. N может принимать значения от 0 до 4. |
| `-std=<standard>` | указание стандарта языка С++. Возможные значения: `c++11`, `c++14`, `c++17`, `c++20`, `c++23` |
| `-l`     | подключение библиотеки |
| `-I`     | указание пути к заголовочным файлам |
| `-L`     | указание пути к библиотекам |

Выполнять компиляцию каждого файла и сборку приложения - это становится утомительной процедурой. Поэтому для автоматизации данного процесса используют различные системы сборки проектов.

## Системы сборки проектов

Автоматизация сборки — этап процесса разработки программного обеспечения, заключающийся в автоматизации широкого спектра задач, решаемых программистами в их повседневной деятельности.

Включает такие действия, как:

- компиляция исходного кода в объектный модуль,
- сборка бинарного кода в исполняемый файл,
- выполнение тестов,
- развёртывание программы в целевой среде,
- Написание сопроводительной документации или описание изменений новой версии,
- Конфигурация и подготовка файлов к сборке,
- Сбор и передача информации итоговой программе (версия программы, системы, компилятора, аппаратная информация, системная информация, лицензия программы, имя автора и т. п.).

Основным средством автоматизации сборки является утилита `make`, которая во многом определила стиль и методы для инструментов, появившихся позднее. Утилита `make` работает с файлами `Makefile`. Данный формат поддерживается в большинстве широко используемых инструментов (`Automake`, `CMake`, `imake`, `qmake`, `nmake`, `wmake`, `Apache Ant`, `Apache Maven`, `OpenMake Meister`, `Gradle`).

Ключевые требования, предъявляемые средствам автоматизации — поддержка технологий непрерывной интеграции, в частности, постоянных "ночных сборок", управление зависимостями исходного кода, обеспечение разностной сборки, уведомление при совпадении исходного кода (после сборки) с имеющимися двоичными файлами, предоставление удобных отчётов о результатах компиляции и компоновки, автоматический запуск тестов и условное выполнение в зависимости от результатов прохождения.

Виды автоматизации, применяемые в различных инструментах:

- автоматизация по запросу (on-demand automation): запуск пользователем сценария в командной строке,
- запланированная автоматизация (scheduled automation): непрерывная интеграция, происходящая в виде ночных сборок,
- условная автоматизация (triggered automation): непрерывная интеграция, выполняющая сборку при каждом подтверждении изменения кода (commit) в системе управления версиями.

### make

`make` - утилита, автоматизирующая процесс преобразования файлов из одной формы в другую. Чаще всего это компиляция исходного кода в объектные файлы и последующая компоновка в исполняемые файлы или библиотеки.

Утилита использует специальные файлы, обычно называемые `Makefile`, в которых описаны зависимости между файлами и команды для их преобразования.

### Ninja

`Ninja` - это кроссплатформенная консольная утилита, представляющая из себя систему сборки программного обеспечения из исходного кода. Утилита Ninja была разработана Эваном Мартином, сотрудником компании Google.

Ninja представляет собой улучшенную и доработанную версию утилиты Make. Главная цель которой — автоматизация сборки и её ускорение, а также ускорение последующих пересборок, на основе сгенерированных утилитой файлов и решение типовых проблем при кроссплатформенной разработке.

### Autotools

`Autotools` - это система сборки проекта GNU, набор программных средств, предназначенных для поддержки переносимости исходного кода программ между UNIX-подобными системами.

Перенос кода с одной системы на другую может оказаться непростой задачей. Различные реализации компилятора языка Си могут существенно различаться: некоторые функции языка могут отсутствовать, иметь другое имя или находиться в разных библиотеках. Программист может решить эту задачу, используя макросы и директивы препроцессора, например `#if`, `#ifdef` и прочие. Но в таком случае пользователь, компилирующий программу на своей системе, должен будет определить все эти макросы, что не так просто, поскольку существует множество разных дистрибутивов и вариаций систем. Autotools вызываются последовательностью команд `./configure && make && make install` и решают эти проблемы автоматически.

Система сборки `GNU Autotools` широко используется во многих проектах с открытым исходным кодом. `GNU Autotools` включает в себя:

- `Autoconf` - утилита, генерирующая файл `configure` на базе файла `configure.ac` ( или `configure.in`). Созданный файл запускается пользователем, в результате чего скрипт проверяет особенности системы и создает `Makefile`.
- `Automake` - читает файлы Makefile.am и создаёт переносимый Makefile, то есть Makefile.in, который затем после обработки скриптом конфигурации становится Makefile и используется утилитой make.
- `Libtool` - управляет созданием библиотек в Unix-подобных операционных системах.

### CMake

`CMake` - кроссплатформенное программное средство автоматизации сборки программного обеспечения из исходного кода. Не занимается непосредственно сборкой, а лишь генерирует файлы сборки из предварительно написанного файла сценария `CMakeLists.txt` и предоставляет простой единый интерфейс управления. Помимо этого, способно автоматизировать процесс установки и сборки пакетов.

Считается альтернативой распространённой в сообществе GNU системе `Autotools`, разработанной на базе Perl и M4, основными недостатками которой считаются необходимость нетривиальных навыков для практического использования и несовместимость версий в ряде случаев.

## Устройство Makefile

Для использования системы сборки `make` необходимо создать файл `Makefile`.

Правила написания `Makefile` следующие:

- в документе `Makefile` могут быть определены переменные, команды и комментарии.
- переменные обычно они объявляются в начале документа и определяются в виде `<имя> = <значение>`. Переменные могут быть использованы в документе в виде `$(<имя>)`.
- комментарии начинаются с символа `#` и продолжаются до конца строки.
- каждое правило документа есть структура

```makefile
<правило> : [<зависимость> [...]]
    [<команда>]
```

- Правило может иметь несколько зависимостей, или не иметь вовсе. Если правило имеет зависимости, то сначала выполняются они, в том порядке, как они перечислены, а потом команда / команды правила.
- каждая зависимость это определенное в документе `Makefile` другое правило.
- команды начинаются с символа табуляции.

Широко распространена практика именования правил в `Makefile` в соответствии с именами файлов, которые они создают. Например, правило для создания файла `file` будет называться `file`.

Пример `Makefile` для сборки проекта из трех файлов `first.cpp`, `second.cpp` и `main.cpp`:

```makefile
all: file

file: first.o second.o main.o
    g++ first.o second.o main.o -o file -love
    
first.o: first.cpp
    g++ -c first.cpp -O2 -std=c++14 -o first.o

second.o: second.cpp
    g++ -c second.cpp -O2 -std=c++14 -o second.o

main.o: main.cpp
    g++ -c main.cpp -O2 -std=c++14 -o main.o
```

В рамках файла сборки можно определять переменные, что позволяет `Makefile` делать более настраиваемым. Например, в в следующем примере сначала определены компилятор, выходной файл и флаги компиляции и сборки. Это позволяет легко настраивать процесс сборки программы.

```makefile
CC = g++
CXXFLAGS = -O2 -std=c++14
LDFLAGS = -love
OUT = file

all: file

file: first.o second.o main.o
    $(CC) first.o second.o main.o -o $(OUT) $(LDFLAGS)
    
first.o: first.cpp
    $(CC) -c first.cpp $(CXXFLAGS) -o first.o

second.o: second.cpp
    $(CC) -c second.cpp $(CXXFLAGS) -o second.o

main.o: main.cpp
    $(CC) -c main.cpp $(CXXFLAGS) -o main.o
```

Пример `Makefile` с дополнительными правилами:

```makefile
CC = g++
CXXFLAGS = -O2 -std=c++14
LDFLAGS = -love
OUT = file

BINDIR = bin
SRCDIR = src
OBJDIR = obj

all: prepare $(OUT)

prepare:
   mkdir -p $(OBJDIR) $(BINDIR)

clean:
   rm -f $(OBJDIR)/*.o $(BINDIR)/*

help:
   @echo Usage:
   echo make - build application
   echo make clean - remove build artifacts
   echo make help - show help

$(OUT): $(OBJDIR)/first.o $(OBJDIR)/second.o $(OBJDIR)/main.o
    $(CC) $(OBJDIR)/first.o $(OBJDIR)/second.o $(OBJDIR)/main.o -o $(BINDIR)/$(OUT) $(LDFLAGS)
    
$(OBJDIR)/first.o:
    $(CC) -c $(SRCDIR)/first.cpp $(CXXFLAGS) -o $(OBJDIR)/first.o

$(OBJDIR)/second.o:
    $(CC) -c $(SRCDIR)/second.cpp $(CXXFLAGS) -o $(OBJDIR)/second.o

$(OBJDIR)/main.o:
    $(CC) -c $(SRCDIR)/main.cpp $(CXXFLAGS) -o $(OBJDIR)/main.o
```

Сборка проекта выполняется запуском утилиты `make`. В этом случае выполняется первое определенное правило. Также можно запустить конкретное правило из `Makefile`, для этого необходимо указать это правило в качестве параметра. Например, очистка проекта для последнего `Makefile` будет выполняться командой `make clean`.

## Пример универсального Makefile

Пусть проект состоит из нескольких файлов, распределенных по каталогам:

- `bin` - хранит результат сборки проекта
- `include` - заголовочные файлы
- `src` - файлы `cpp`
- `lib` - внешние зависимости (библиотеки)
- `obj` - временные файлы, создаваемые в процессе сборки проекта

В этом случае `Makefile` будет выглядеть следующим образом:

```makefile
CC = g++
CXXFLAGS = -O2 -std=c++20 -I include
LDFLAGS = -L lib

BINDIR = bin
SRCDIR = src
OBJDIR = obj

SRC = $(wildcard $(SRCDIR)/*.cpp)
OBJ = $(patsubst $(SRCDIR)/%.cpp, $(OBJDIR)/%.o, $(SRC))

APP = app

all: prepare $(APP)

prepare:
    mkdir -p $(OBJDIR) $(BINDIR)

clean:
    rm -f $(OBJDIR)/*.o $(BINDIR)/*

help:
    @echo Usage:
    echo make - build application
    echo make clean - remove build artifacts
    echo make help - show help

$(APP): $(OBJ)
    $(CC) $(OBJ) -o $(BINDIR)/$(APP) $(LDFLAGS)

$(OBJDIR)/%.o: $(SRCDIR)/%.cpp
    $(CC) -c $< $(CXXFLAGS) -o $@
```

## Библиография

1. [GNU make](https://www.gnu.org/software/make/)
2. [Ninja](https://ninja-build.org/)
3. [Autoconf](https://www.gnu.org/savannah-checkouts/gnu/autoconf/manual/autoconf-2.71/autoconf.html)
4. [CMake](https://cmake.org)
