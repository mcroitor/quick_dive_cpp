# Операции

- [Операции](#операции)
  - [Понятие операции](#понятие-операции)
  - [Арифметические операции](#арифметические-операции)
  - [Инкремент / декремент](#инкремент--декремент)
  - [Составные операторы.](#составные-операторы)
  - [Логические операции](#логические-операции)
  - [Битовые операции](#битовые-операции)
  - [Приоритет операций](#приоритет-операций)
  - [Перегрузка операций](#перегрузка-операций)
  - [Оператор сравнения](#оператор-сравнения)
  - [Оператор "spaceship"](#оператор-spaceship)
  - [Ссылки](#ссылки)

## Понятие операции

В общем смысле операция это действие (процесс), производимое над одним или несколькими значениями, называемыми _операндами_. Данное действие определяется _оператором_ - специальной конструкцией языка.

Операции бывают

 - _унарные_ - с одним операндом. Пример унарной операции - инкремент, изменение знака числа;
 - _бинарные_ - с двумя операндами. Пример бинарной операции - сложение, умножение, `или`;
 - _тернарные_ - с тремя операндами.

## Арифметические операции

В языке C/C++ поддерживаются следующие арифметические операции:
 * `+` – сложение;
 * `-` – вычитание;
 * `*` – умножение;
 * `/` – деление;
 * `%` – остаток от деления.

Арифметические операции можно применять для:

 * целочисленных типов;
 * типов с плавающей запятой (вещественных типов);
 * типов (классов), которые содержат перегруженные арифметические операции.

Если в арифметическом выражении используются операнды разных типов, то компилятор неявно преобразует операнд меньшего типа к типу операнда большего типа.

Операции `+` и `–` могут использоваться как унарные, для изменения знака выражения.

Операция `%` используется только над целочисленными типами.

Если в делении операнды являются целыми числами, то результат деления – целое число.

## Инкремент / декремент

В языке C++ определены два оператора, которые осуществляют увеличение или уменьшение целочисленной величины на 1:
 * оператор `++` – инкремент;
 * оператор `––`  – декремент.
Эти операторы являются унарными, то есть требуют одного операнда. Эти операторы могут размещаться до и после операнда.

 * `A++` эквивалентно записи `A = A + 1`
 * `++A` эквивалентно записи `A = A + 1`
 * `A--` эквивалентно записи `A = A - 1`
 * `--A` эквивалентно записи `A = A - 1`

## Составные операторы.

Составные операторы позволяют выполнить арифметическую операцию и записать результат в первый операнд.

Определены следующие составные операции: `+=`, `-=`, `*=`, `/=`, `%=`, `&=`, `|=`, `^=`, `<<=`, `>>=`. 

Например, `A += B` эквивалентно `A = A + B`.

## Логические операции

Логические операции являются составными элементами логических выражений и используются при организации условной логики, например, в ветвлениях (if) или циклах (while, for).

В языке C++ существует 3 логические операции:

 * `&&` - операция И (конъюнкция);
 * `||` - операция ИЛИ (дизъюнкция);
 * `!` – операция НЕ (отрицание).

Логические операции позволяют составить из нескольких простых логических выражений одно более сложное.

Правила логических операций:

| `A` | `B` | `A && B` | `A \|\| B` | `!A` |
| --- | --- | -------- | -------- | ---- |
| true | true | true | true | false |
| true | false | false | true | false |
| false | true | false | true | true |
| false | false | false | false | true |


## Битовые операции

Язык С/С++ поддерживает следующие поразрядные (выполняющиеся над разрядами, битами) логические операции:

 * `&` – поразрядное логическое И (AND);
 * `^` – поразрядное сложение по модулю 2 (XOR — исключающее ИЛИ);
 * `|` – поразрядное логическое ИЛИ (OR);
 * `~` – поразрядная инверсия (NOT).

Также есть операции поразрядного сдвига:

 * `<<` – сдвиг влево значения левого операнда на заданное количество бит правым операндом;
 * `>>` – сдвиг вправо значения левого операнда на заданное количество бит правым операндом.

| __бит1__ | __бит2__ | `&` | `\|` | `^` | `~` |
| -------- | -------- | --- | ---- | --- | --- |
| 0 | 0 | 0 | 0 | 0 | 1 |
| 0 | 1 | 0 | 1 | 1 | 1 |
| 1 | 0 | 0 | 1 | 1 | 0 |
| 1 | 1 | 1 | 1 | 0 | 0 |

Следующий пример показывает поразрядное выполнение операций над числами 17 и 45:

| Выражение | 128 | 64 | 32 | 16 | 8 | 4 | 2 | 1 | Результат |
| --------- | --- | -- | -- | -- | - | - | - | - | --------- |
| 17        | 0   | 0  | 0  | 1  | 0 | 0 | 0 | 1 | 17        |
| 45        | 0   | 0  | 1  | 0  | 1 | 1 | 0 | 1 | 45        |
| 17 & 45   | 0   | 0  | 0  | 0  | 0 | 0 | 0 | 1 | 1         |
| 17 | 45   | 0   | 0  | 1  | 1  | 1 | 1 | 0 | 1 | 61        |
| 17 ^ 45   | 0   | 0  | 1  | 1  | 1 | 1 | 0 | 0 | 60        |
| ~17       | 1   | 1  | 1  | 0  | 1 | 1 | 1 | 0 | 238       |

## Приоритет операций

| приоритет | оператор | описание | группа |
| --------- | -------- | -------- | ------ |
| 1 | `::` | Разрешение области | доступ |
| 2 | `.`  | Выбор члена объекта | доступ |
| 2 | `->` | Выбор члена для указателя на объект | доступ |
| 2 | `[]` | Индекс массива | доступ |
| 2 | `()` | Вызов функции | другое |
| 2 | `++` | Постфиксный инкремент | инкремент / декремент |
| 2 | `--` | Постфиксный декремент | инкремент / декремент |
| 2 | `typeid` | Имя типа | специальные |
| 2 | `const_cast` | Константное преобразование типа | специальные |
| 2 | `dynamic_cast` | Динамическое преобразование типа | специальные |
| 2 | `reinterpret_cast` | Интерпретируемое преобразование типа | специальные |
| 2 | `static_cast` | Статическое преобразование типа | специальные |
| 3 | `sizeof` | Размер объекта или типа | специальные |
| 3 | `++` | Префиксный инкремент | инкремент / декремент |
| 3 | `--` | Префиксный декремент | инкремент / декремент |
| 3 | `~` | Дополнение к одному (побитовое дополнение) | арифметические |
| 3 | `!` | Логическое не | логические |
| 3 | `-` | Унарное отрицание | арифметические |
| 3 | `+` | Унарный плюс | арифметические |
| 3 | `&` | Взятие адреса | доступ |
| 3 | `*` | Косвенное обращение | доступ |
| 3 | `new` | Создание объекта | специальные |
| 3 | `delete` | Уничтожение объекта | специальные |
| 3 | `()` | Приведение типа | специальные |
| 4 | `.*` | Выбор указателя на член объекта | доступ |
| 4 | `->*` | Указатель на член (указатель на объект) | доступ |
| 5 | `*` | Умножение | арифметические |
| 5 | `/` | Деление | арифметические |
| 5 | `%` | Модуль | арифметические |
| 6 | `+` | Сложение | арифметические |
| 6 | `-` | Вычитание | арифметические |
| 7 | `<<` | Сдвиг влево | арифметические |
| 7 | `>>` | Сдвиг вправо | арифметические |
| 8 | `<=>` | Сравнение | сравнения |
| 9 | `<` | Меньше | сравнения |
| 9 | `>` | Больше | сравнения |
| 9 | `<=` | Меньше или равно | сравнения |
| 9 | `>=` | Больше или равно | сравнения |
| 10 | `==` | Сравнение (равенство) | сравнения |
| 10 | `!=` | Не равно (неравенство) | сравнения |
| 11 | `&` | Побитовое И | арифметические |
| 12 | `^` | Побитовое исключающее ИЛИ | арифметические |
| 13 | `\|` | Побитовое ИЛИ | арифметические |
| 14 | `&&` | Логическое И | логические |
| 15 | `\|\|` | Логическое ИЛИ | логические |
| 16 | `?:` | Условная логика | другое |
| 16 | `=` | Присваивание | присваивание |
| 16 | `*=` | Присваивание умножения | присваивание |
| 16 | `/=` | Присваивание деления | присваивание |
| 16 | `%=` | Присваивание остатка от деления | присваивание |
| 16 | `+=` | Присваивание сложения | присваивание |
| 16 | `-=` | Присваивание вычитания | присваивание |
| 16 | `<<=` | Присваивание сдвига влево | присваивание |
| 16 | `>>=` | Присваивание сдвига вправо | присваивание |
| 16 | `&=` | Назначение побитового И | присваивание |
| 16 | `\|=` | Назначение побитового включающего ИЛИ | присваивание |
| 16 | `^=` | Назначение побитового исключающего ИЛИ | присваивание |
| 17 | `,` | Запятая (разделитель команд) | другое |

## Перегрузка операций

Часто, для удобства, бывает полезно переопределить некоторый оператор для класса \(например, + для векторов\). Тогда запись программы становится более компактной и понятной. Общая форма определения оператора выглядит следующим образом:

`<return_type> operator <operator_sign> (<operator_parametres>);`

Операторы бывают унарные \(работающие с одним объектом\) и бинарные \(работающие с двумя объектами\). Примеры унарных операторов: ++, --, \* \(оператор разыменования\). Примеры бинарных операторов: +, +=, \* \(умножение\), ==.

Операторы являются теми же функциями, только со специальными именами. Они могут быть объявлены как вне класса, так и как член класса. Пример перегрузки операторов:


```cpp
class int_pair{
    int first, second;
public:
    int_pair(int f = 0, int s = 0): first(f), second(s) {}
    bool operator == (const int_pair& p) const {
        return (first == p.first) && (second == p.second);
    }
    std::string to_string() const {
        return "[ " + std::to_string(first) + ", " + std::to_string(second) + " ]";
    }
};

bool operator != (const int_pair& p1, const int_pair& p2){
    return !(p1 == p2);
}

std::ostream& operator << (std::ostream& out, const int_pair& p) {
    out << p.to_string();
    return out;
}
```

Унарные операторы объявляются как часть класса. Бинарные операторы могут быть объявлены как внутри класса, так и вне класса. Бинарный оператор, объявленный внутри класса, имеет только один входной параметр \(вторым параметром оператора будет объект, оператор которого вызывается\). Бинарные операторы, объявленные вне класса, имеют два параметра.

 > __Рекомендация:__ для определения, где лучше всего описывать оператор - внутри класса или вне его, - спросите себя, изменяет ли этот оператор свои операнды. Если изменяет - то этот оператор - часть класса. Если не изменяет, то оператор лучше всего определить вне класса. Например, операция присваивания меняет правый операнд, значит лучше определить операнд внутри класса; операция сложения не меняет своих операндов, значит надо её определить вне класса.

В следующем примере показаны способы перегрузки операторов для двумерного вектора:

```cpp
class vector{
    float x, y;
public:
    vector(float p1 = 0, float p2 = 0): x(p1), y(p2) {}
    vector operator = (const vector& p){
        x = p.x;
        y = p.y;
        return *this;
    }
    void operator += (const vector& p){
        x += p.x;
        y += p.y;
    }
};

vector operator + (const vector& p1, const vector& p2){
    vector tmp;
    tmp = p1;
    tmp += p2;
    return tmp;
}
```

## Оператор сравнения

Для сравнивания объектов используется базовая операция `a == b`, операция `a != b` является производной от базовой.

```cpp
bool operator != (const int& a, const int& b) {
    return !(a == b);
}
```

## Оператор "spaceship"

До стандарта `C++20` для упорядочивания использовалась базовая операция `<` (_меньше_). Остальные операторы были производными от неё и реализованы в стандартной библиотеке, в пространстве имён `std::rel_ops`.

Начиная со стандарта `C++20` в язык был введен оператор __spaceship__ ("космический корабль") - `<=>`, который стал базовым для операций упорядочивания. Семантика оператора является следующей:

 * `a <=> b` меньше нуля, если `a < b`;
 * `a <=> b` меньше или равно нулю, если `a <= b`;
 * `a <=> b` больше нуля, если `a > b`;
 * `a <=> b` больше или равно нулю, если `a >= b`.

## Ссылки

1. [C++ Operator Precedence, cppreference.com](https://en.cppreference.com/w/cpp/language/operator_precedence)
2. [Andrey2008, Операции сравнения в C++20, Habr: Pvs-Studio](https://habr.com/ru/companies/pvs-studio/articles/465575/)
3. 