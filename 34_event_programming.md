# Событийное программирование

- [Событийное программирование](#событийное-программирование)
  - [Основные понятия](#основные-понятия)
  - [Архитектура приложения](#архитектура-приложения)
  - [Пример](#пример)
  - [Библиотеки и фреймворки](#библиотеки-и-фреймворки)
  - [Библиография](#библиография)

## Основные понятия

Информационную систему можно рассматривать как некоторый объект, обладающий состоянием и поведением. Состояние информационной системы определяется набором описывающих данную систему значений (атрибуты). Поведение системы определяется набором действий, которые могут быть выполнены над системой.

Изменение состояния некоторого объекта называется __событием__. В результате события создается сообщение, содержащее информацию о произошедшем событии, которое может быть обработано системой. Часто событие и сообщение, создаваемое в результате события, используются как синонимы.

События, инициированные внешними факторами, называются __внешними событиями__, а события, инициированные самой системой, называются __внутренними событиями__.

Информационная система реагирует на сообщения о событиях, обрабатывая их специальными методами, называемыми __обработчиками событий__.

__Событийное программирование__ (или __Событийно-ориентированное программирование__, en. _event-driven programming_) — это парадигма программирования, в которой основное внимание уделяется обработке событий. Программа, написанная в соответствии с принципами событийного программирования, представляет собой набор обработчиков событий, которые вызываются при возникновении определённых событий.

Событийное программирование подразумевает разделение программы на независимые части, каждая из которых отвечает за обработку определённого события. Эти части информационной системы могут работать в отдельных потоках выполнения и взаимодействовать друг с другом через события.

Это позволяет упростить разработку и поддержку программы, так как каждый обработчик события может быть реализован в виде отдельной функции или метода.

## Архитектура приложения

Событийное программирование широко используется в графических интерфейсах, так как позволяет реагировать на действия пользователя. В графическом интерфейсе события могут быть связаны с различными элементами интерфейса, такими как кнопки, поля ввода, меню и т.д. Каждый элемент интерфейса может генерировать события, на которые должны реагировать соответствующие обработчики событий.

Событийное программирование позволяет разделить логику приложения на независимые части, каждая из которых отвечает за обработку определённого события. Это упрощает разработку и поддержку программы, так как каждый обработчик события может быть реализован в виде отдельной функции или метода.

Простейшая архитектура приложения, построенного на основе событийного программирования, включает в себя следующие компоненты:

- __Событие__ (en. _event_) — это сигнальное сообщение, которое отправлено информационной системе и может быть обработано. Событие содержит информацию о типе события и дополнительные данные, необходимые для его обработки.

Простейший способ определить события в системе — использовать перечисление (enum) для всех возможных типов событий. Например, для графического интерфейса можно определить следующие типы событий:

```cpp
enum class EventType {
    NoEvent,
    ButtonClick,
    MouseMove,
    KeyPress
};

struct Event {
    EventType type;
    // дополнительные данные
}
```

Более сложные события могут содержать дополнительные данные, например, информацию об объекте, сгенерировавшем событие.

- __Источник события__ (en. _event source_) — это объект, который генерирует события. Событийный источник может быть представлен как элемент графического интерфейса (например, кнопка, поле ввода), так и другой частью программы (например, сетевой сокет, файловый дескриптор).
- __Очередь событий__ (en. _event queue_) — это структура данных, в которой хранятся события, ожидающие обработки. Очередь событий позволяет разделить процесс генерации событий и их обработки.

Простейшая реализация очереди событий — это FIFO-очередь (First-In-First-Out), в которой события добавляются в конец и извлекаются из начала очереди.

```cpp
class EventQueue {
    std::deque<Event> events;
public:
    void Push(const Event& event) {
        events.push_back(event);
    }

    Event Pop() {
        if(events.empty()) {
            return Event{EventType::NoEvent};
        }
        Event event = events.front();
        events.pop_front();
        return event;
    }
};
```

- __Обработчик события__ (en. _event handler_) — это функция или метод, которая вызывается при возникновении определённого события. Событийный обработчик выполняет необходимые действия в ответ на событие.

Обычно определяется интерфейс обработчика события, который объявляет метод для обработки события. Каждый обработчик события реализует этот интерфейс.

```cpp
struct EventHandler {
    virtual void operator()(const Event& event) = 0;
    virtual ~EventHandler() = default;
};
```

Впрочем, обработчики событий могут быть реализованы как методы класса, в этом случае объект класса регулярно должен проверять очередь событий и вызывать соответствующий обработчик события, предназначенный для данного объекта.

- __Диспетчер событий__ (en. _event dispatcher_) — это компонент программы, который отвечает за генерацию событий и их добавление в очередь событий. Событийный диспетчер связывает событийный источник с соответствующими обработчиками событий.

Простейший способ реализовать диспетчер событий — использовать таблицу сопоставления событий и обработчиков событий. Также можно использовать обычный переключатель (switch) для выбора обработчика события.

```cpp
EventHandler buttonClickHandler;
EventHandler mouseMoveHandler;
EventHandler keyPressHandler;

void DispatchEvent(const Event& event) {
    switch (event.type) {
        case EventType::ButtonClick:
            buttonClickHandler(event);
            break;
        case EventType::MouseMove:
            mouseMoveHandler(event);
            break;
        case EventType::KeyPress:
            keyPressHandler(event);
            break;
    }
}
```

- __Событийный цикл__ (en. _event loop_) — это основной цикл программы, который извлекает события из очереди событий и передает их на обработку соответствующим обработчикам.

Обычно событийный цикл представляет собой бесконечный цикл, который извлекает события из очереди событий и передает их на обработку. При этом событийный цикл может быть остановлен, например, при завершении работы программы.

```cpp
EventQueue eventQueue;

void EventLoop() {
    while (true) {
        Event event = eventQueue.Pop();
        DispatchEvent(event);
    }
}
```

## Пример

В качестве примера рассмотрим систему, в которой живет виртуальный кот. Виртуальный кот может генерировать следующие события:

- __проголодался__ — кот проголодался и хочет есть;
- __хочет ласки__ — кот хочет ласки и играть;
- __наелся__ — кот наелся и хочет спать.

Пользователь может генерировать следующие события:

- __кормить__ — пользователь кормит кота;
- __гладить__ — пользователь гладит кота;
- __выйти из системы__ — пользователь выходит из системы.

События генерируются виртуальным котом и пользователем и добавляются в очередь событий. Система обработки событий извлекает события из очереди и передает их на обработку соответствующим обработчикам.

```cpp
enum class EventType {
    CatHungry,
    CatWantsToPlay,
    CatSleepy,
    FeedCat,
    PetCat,
    SystemExit
};

struct Event {
    EventType type;
    // дополнительные данные
};
```

В этом случае обработчики событий могут быть реализованы следующим образом:

```cpp
struct EventHandler {
    virtual void operator()(const Event& event) = 0;
    virtual ~EventHandler() = default;
};

struct CatHungryHandler : public EventHandler {
    void operator()(const Event& event) override { /* обработка события */ }
};

struct CatWantsToPlayHandler : public EventHandler {
    void operator()(const Event& event) override { /* обработка события */ }
};

struct CatSleepyHandler : public EventHandler {
    void operator()(const Event& event) override { /* обработка события */ }
};

struct FeedCatHandler : public EventHandler {
    void operator()(const Event& event) override { /* обработка события */ }
};

struct PetCatHandler : public EventHandler {
    void operator()(const Event& event) override { /* обработка события */ }
};

struct SystemExitHandler : public EventHandler {
    void operator()(const Event& event) override { exit(0); }
};
```

Без виртуального деструктора при удалении через `std::shared_ptr<EventHandler>` может возникнуть утечка памяти, если производный класс выделяет ресурсы.

Диспетчер событий иногда реализуется как таблица сопоставления событий и обработчиков событий:

```cpp
std::map<EventType, std::shared_ptr<EventHandler>> eventHandlers = {
    {EventType::CatHungry, std::make_shared<CatHungryHandler>()},
    {EventType::CatWantsToPlay, std::make_shared<CatWantsToPlayHandler>()},
    {EventType::CatSleepy, std::make_shared<CatSleepyHandler>()},
    {EventType::FeedCat, std::make_shared<FeedCatHandler>()},
    {EventType::PetCat, std::make_shared<PetCatHandler>()},
    {EventType::SystemExit, std::make_shared<SystemExitHandler>()}
};
```

Уже знакомый нам событийный цикл извлекает события из очереди и передает их на обработку соответствующим обработчикам:

```cpp
void EventLoop() {
    while (true) {
        Event event = eventQueue.Pop();
        (*eventHandlers[event.type])(event);
    }
}
```

Важно, чтобы объекты программы не взаимодействовали напрямую друг с другом. Вместо этого они должны генерировать события и передавать их на обработку соответствующим обработчикам. Это позволяет уменьшить связанность между компонентами и облегчает расширение программы.

## Библиотеки и фреймворки

Существует множество библиотек и фреймворков, которые упрощают разработку программ, написанных с использованием событийного программирования. Некоторые из наиболее популярных библиотек и фреймворков для разработки графических интерфейсов:

- __WinAPI__ — набор функций для разработки приложений под Windows (только для Windows).
- __MFC__ — библиотека для разработки графических интерфейсов на C++ (только для Windows).
- __Qt__ — кроссплатформенный фреймворк для разработки графических интерфейсов на C++.
- __GTK__ — библиотека для разработки графических интерфейсов на C.
- __wxWidgets__ — кроссплатформенная библиотека для разработки графических интерфейсов на C++.
- __FLTK__ — кроссплатформенная библиотека для разработки графических интерфейсов на C++.

Взаимодействие с графическим интерфейсом в этих библиотеках осуществляется с помощью событийного программирования. Каждый элемент интерфейса (например, кнопка, поле ввода) генерирует события, на которые можно реагировать, определяя соответствующие обработчики событий.

## Библиография

1. [Событийно-ориентированное программирование, Wikipedia](https://ru.wikipedia.org/wiki/Событийно-ориентированное_программирование)
2. Фаулер М. _Паттерны проектирования. Повторное использование объектно-ориентированного знания._ СПб.: Питер. (2009)
3. Gamma E., Helm R., Johnson R., Vlissides J. _Design Patterns: Elements of Reusable Object-Oriented Software._ Addison-Wesley. (1994)
4. [Windows API, Microsoft](https://docs.microsoft.com/en-us/windows/win32/apiindex/windows-api-list)
5. [MFC, Microsoft](https://docs.microsoft.com/en-us/cpp/mfc/mfc-desktop-applications)
6. [Qt, Qt Project](https://www.qt.io/)
7. [GTK, GTK](https://www.gtk.org/)
8. [wxWidgets, wxWidgets](https://www.wxwidgets.org/)
9. [FLTK, FLTK](https://www.fltk.org/)
