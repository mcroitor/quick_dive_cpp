# Развитие языка С++: стандарты, компиляторы, среда разработки

- [Развитие языка С++: стандарты, компиляторы, среда разработки](#развитие-языка-с-стандарты-компиляторы-среда-разработки)
  - [история языка](#история-языка)
  - [философия языка](#философия-языка)
  - [современное состояние языка](#современное-состояние-языка)
  - [компиляторы](#компиляторы)
    - [GCC](#gcc)
    - [MSVC](#msvc)
    - [Intel C++ Compiler](#intel-c-compiler)
    - [clang](#clang)
    - [llvm](#llvm)
  - [среды разработки](#среды-разработки)
  - [библиография](#библиография)

## история языка

Язык создан __Бьёрном Страуструпом__ в начале 80х годов как развитие языка С, который захотел добавить в язык некоторые возможности языка Симула, а именно - работу с классами и объектами. Поэтому сначала язык назывался _"Си с классами"_ (_C with classes_). Предварительное описание языка было опубликовано в виде технического отчета в Bell Labs в апреле 1980 года [^1].

При разработке языка Страуструп пользовался следующими критериями:

 - хороший инструмент должен предоставлять средства организации программ, подобные имеющимся в Simula: классы, форму их иерархии, поддержку параллельности и сильный (т.е. статический) контроль типов, основанный на классах. Эти критерии представлялись существенными для поддержки процесса проектирования, а не для реализации программы;
 - необходимо, чтобы он генерировал программы, работающие так же быстро, как написанные на BCPL (предшественник Си), и обладал способностью BCPL объединять раздельно откомпилированные модули в единую программу. Должно быть простое соглашение о связях, чтобы удалось объединять модули, написанные на разных языках, таких как С, Algol68, Fortran, BCPL, ассемблер и т.д. Иначе программист будет вынужден бороться с ограничениями, присущими какому-то одному языку;
 - инструмент должен обеспечивать переносимую реализацию. Отсюда следует, что должно быть несколько источников реализации инструмента. Не должно быть также сложной системы поддержки времени исполнения, которую трудно переносить, и допустима лишь очень ограниченная зависимость инструмента от операционной системы.

Ранняя версия языка была доступна для широкой публики с 1983 года и реализовывала

- классы;
- производные классы (но пока без виртуальных функций);
- контроль доступа - открытый/закрытый;
- конструкторы и деструкторы;
- функции, вызываемые при вызове и возврате (позже исключены);
- дружественные классы;
- контроль и преобразование типов аргументов функции;
- встраиваемые (inline) функции;
- аргументы по умолчанию;
- перегрузка оператора присваивания.

В 1984 году была реализована поддержка виртуальных функций, в связи с чем была объявлена поддержка объектно-ориентированного программирования.

Для работы с новым языком Страуструп разработал _cfront_ - транслятор (препроцессор) с нового языка в язык Си. Данный препроцессор задавал долгие годы направление развития языка, однако после попытки добавить в него обработку исключений, он был заброшен

## философия языка

При разработке языка С++ придерживались следующих целей:

 * создать язык программирования, который программирование более приятным занятием для серьезных программистов
 * лучше С
 * поддерживать абстракции данных
 * поддерживать объектно-ориентированное программирование

Это привело к становлению следующим идеям:

 - Эволюция C++ должна определяться реальными задачами
 - Не устремляться в бесплодную погоню за совершенством
 - C++ должен быть полезен сейчас
 - Каждое средство должно иметь достаточно ясную реализацию
 - Всегда оставлять путь для перехода
 - C++ - это язык, а не законченная система
 - Предоставлять всестороннюю поддержку для каждого поддерживаемого стиля программирования
 - Ничего не заставлять делать насильно
 - Поддерживать устоявшиеся методы проектирования
 - Предоставлять средства для организации программ
 - Точно говорить то, что имеется в виду
 - Все возможности должны быть адекватны
 - Важнее включить полезную возможность, чем предотвращать неправильное использование
 - Поддерживать сборку программ из независимо разработанных частей
 - Никаких неявных нарушений статической системы типов
 - Предоставлять для определенных пользователем типов такую же полноценную поддержку, как для встроенных
 - Локальность - это прекрасно
 - Избегать зависимости от порядка
 - Если есть сомнения, выбирать такой вариант средства, которому легче обучить
 - Синтаксис важен, хотя бывает и нелогичным
 - Использование препроцессора должно быть исключено
 - Использовать традиционные компоновщики
 - Никаких неоправданных несовместимостей с С
 - Не оставлять места для языка более низкого уровня, чем C++, исключая ассемблер
 - Правило нулевых издержек: чем не пользуетесь, за то не платите
 - Если есть сомнения, предоставлять средства для ручного контроля

## современное состояние языка

Уже в конце 80-х годов С++ обрел популярность, в связи с чем появилось немалое количество компиляторов, каждый из которых предлагал свои особенности. В связи с этим, программа, написанная на С++ для одного компилятора могла не собираться другим ( а для больших проектов это было гарантировано). В связи с этим в 1998 году вышел первый стандарт языка С++, который определил модель языка, его синтаксис, стандартную библиотеку и т.д.


## компиляторы

### GCC

[GCC (GNU Compiler Collection)](https://gcc.gnu.org) - набор компиляторов для различных языков программирования, разработанный в рамках проекта GNU. GCC является свободным программным обеспечением, распространяется в том числе фондом свободного программного обеспечения (FSF) на условиях GNU GPL и GNU LGPL и является ключевым компонентом GNU toolchain. Он используется как стандартный компилятор для свободных UNIX-подобных операционных систем.

Изначально названный GNU C Compiler, поддерживал только язык Си. Позднее GCC был расширен для компиляции исходных кодов на таких языках программирования, как C++, Objective-C, Java, Фортран, Ada, Go, GAS и D.

В настоящее время GCC поддерживается группой программистов со всего мира. GCC является лидером по количеству процессоров и операционных систем, которые он поддерживает.

Будучи официальным компилятором системы GNU, GCC также является главным компилятором для сборки ряда других операционных систем; среди них — различные варианты Linux и BSD (ранее, в настоящее время используется Clang LLVM), а также ReactOS, macOS, OpenSolaris, NeXTSTEP, BeOS и Haiku.

GCC часто выбирается для разработки программного обеспечения, которое должно работать на большом числе различных аппаратных платформ. Различия между "родными" для каждой из аппаратных платформ компиляторами приводят к трудностям при разработке кода, который бы корректно компилировался разными компиляторами, а кроме того, при использовании различных компиляторов сильно усложняются сборочные скрипты, которые должны собирать ПО для всех аппаратных платформ. При использовании GCC для компиляции кода под разные платформы будет использован один и тот же синтаксический анализатор. Поэтому, если удалось собрать программу для одной из целевых платформ, то велика вероятность, что программа нормально соберётся и для других платформ.

Для работы с GCC под Windows обычно используются

 - MingW
 - Cygwin

### MSVC

[MSVC (Microsoft Visual C++)](https://learn.microsoft.com/ru-ru/cpp/) - компилятор для приложений на языке C++, разработанный корпорацией Microsoft и поставляемый либо как часть комплекта Microsoft Visual Studio, либо отдельно в виде бесплатного функционально ограниченного комплекта [Microsoft Visual Studio Community Edition](https://visualstudio.microsoft.com/downloads/).

### Intel C++ Compiler

[Intel C++ Compiler](https://www.intel.com/content/www/us/en/developer/tools/oneapi/dpc-compiler.html) - оптимизирующий компилятор, разрабатываемый фирмой Intel для процессоров семейств x86, x86-64 и IA-64. Главным достоинством компилятора являются выполняемые им высокоуровневые, а также целевые оптимизации под процессоры Intel. Компилятор работает под ОС Linux, Windows, macOS.

### clang

[Clang](https://clang.llvm.org) является фронтендом для языков программирования C, C++, Objective-C, Objective-C++ (англ.) и OpenCL C, использующимся совместно с фреймворком LLVM. Clang транслирует исходные коды в байт-код LLVM, затем фреймворк производит оптимизации и кодогенерацию.

Целью проекта является создание замены GNU Compiler Collection (GCC). Разработка ведётся согласно концепции open source в рамках проекта LLVM.

В проекте участвуют работники нескольких корпораций, в том числе Google и Apple. Исходный код доступен на условиях BSD-подобной лицензии.

### llvm

LLVM (Low Level Virtual Machine) - проект программной инфраструктуры для создания компиляторов и сопутствующих им утилит. Состоит из набора компиляторов из языков высокого уровня (так называемых «фронтендов»), системы оптимизации, интерпретации и компиляции в машинный код.

Написан на C++, обеспечивает оптимизации на этапах компиляции, компоновки и исполнения. Изначально в проекте были реализованы компиляторы для языков Си и C++ при помощи фронтенда Clang, позже появились фронтенды для множества языков, в том числе: C#, Fortran, Haskell, Java (байткод), JavaScript, Ruby, Rust, Scala, Swift и многие другие.

LLVM может создавать машинный код для множества архитектур, в том числе ARM, x86, x86-64, PowerPC, MIPS, SPARC, RISC-V и других (включая GPU от Nvidia и AMD).

Для компиляции С++ кода LLVM использует свою версию компилятора GCC.

## среды разработки

## библиография

[^1][Страуструп Бьёрн, Дизайн и философия С++]